# Startup Latency Analysis - Code Changes

This document summarizes the changes made to address startup latency concerns in MockForge.

## Changes Made

### 1. HTTP Server Timing Instrumentation

**File**: `crates/mockforge-http/src/lib.rs`

**Function**: `build_router()` (lines 250-393)

**Changes**:
- Added `use std::time::Instant;` for timing measurements
- Added `startup_start` timer at the beginning of the function
- Added timing for:
  - OpenAPI spec loading (spec_load_start/duration)
  - Route registry creation (registry_start/duration)
  - Route extraction (extract_start/duration)
  - Overrides loading (overrides_start/duration)
  - Router building (router_build_start/duration)
- Added total startup time logging at the end
- Changed log levels:
  - `info!` for major milestones with timing
  - `debug!` for detailed sub-operations

**Example log output**:
```rust
info!("Successfully loaded OpenAPI spec from {} (took {:?})", spec_path, spec_load_duration);
info!("Created OpenAPI route registry with {} routes (took {:?})", registry.routes().len(), registry_duration);
debug!("Extracted route information (took {:?})", extract_duration);
debug!("Built OpenAPI router (took {:?})", router_build_duration);
info!("HTTP router startup completed (total time: {:?})", total_startup_duration);
```

### 2. gRPC Server Timing Instrumentation

**File**: `crates/mockforge-grpc/src/dynamic/mod.rs`

#### Function: `discover_services()` (lines 105-153)

**Changes**:
- Added `use std::time::Instant;` for timing measurements
- Added `discovery_start` timer at the beginning
- Added timing for:
  - Proto file parsing (parse_start/duration)
  - Registry creation (registry_start/duration)
  - Service registration loop (service_reg_start/duration)
- Added total discovery time logging at the end
- Changed log levels:
  - `info!` for major phases with timing
  - `debug!` for individual service registration

#### Function: `start_dynamic_server()` (lines 155-203)

**Changes**:
- Added `use std::time::Instant;` for timing measurements
- Added `startup_start` timer at the beginning
- Added timing for:
  - Reflection proxy creation (reflection_start/duration)
- Added total startup time logging before server start
- Changed log level for reflection proxy creation to `info!`

**Example log output**:
```rust
info!("Proto file parsing completed (took {:?})", parse_duration);
debug!("Registry creation completed (took {:?})", registry_duration);
info!("Service registration completed for {} services (took {:?})", registry.service_names().len(), service_reg_duration);
info!("Service discovery completed (total time: {:?})", total_discovery_duration);
info!("gRPC reflection proxy created (took {:?})", reflection_duration);
info!("gRPC server startup completed (total time: {:?})", total_startup_duration);
```

## Test Scenarios Created

### 1. Benchmark Directory Structure

```
benchmarks/startup/
├── README.md                           # Quick reference guide
├── STARTUP_LATENCY_ANALYSIS.md        # Comprehensive analysis
├── CHANGES.md                          # This file
├── generate_large_spec.py             # Tool to generate OpenAPI specs
├── large_api_100_endpoints.json       # 100-endpoint test spec
├── measure_startup.sh                 # Full benchmark suite
├── quick_test.sh                      # Quick test script
├── test_timing.rs                     # Rust test program (optional)
└── proto/                             # gRPC test protos
    ├── user_service.proto             # 18 methods
    ├── product_service.proto          # 12 methods
    └── order_service.proto            # 12 methods
```

### 2. Large OpenAPI Specification

**File**: `benchmarks/startup/large_api_100_endpoints.json`

**Generated by**: `generate_large_spec.py`

**Characteristics**:
- 100 HTTP endpoints across 20 paths
- 10 resource categories
- Full CRUD operations (GET, POST, PUT, DELETE, partial updates)
- Request/response schemas with realistic structures
- Query parameters, path parameters, request bodies
- ~43KB JSON file size

**Command to regenerate**:
```bash
python3 benchmarks/startup/generate_large_spec.py 100 > benchmarks/startup/large_api_100_endpoints.json
```

### 3. gRPC Proto Files

**Directory**: `benchmarks/startup/proto/`

**Files**:
1. `user_service.proto` - User management service (18 methods)
2. `product_service.proto` - Product/inventory service (12 methods)
3. `order_service.proto` - Order processing service (12 methods)

**Total**: 3 services, ~42 methods, mix of unary/streaming

## Testing the Changes

### Verify Compilation

```bash
# Check HTTP crate compiles
cargo check -p mockforge-http

# Check gRPC crate compiles
cargo check -p mockforge-grpc
```

Both should compile successfully with the changes.

### Run Tests

```bash
# Run HTTP tests
cd crates/mockforge-http && cargo test

# Run gRPC tests
cd crates/mockforge-grpc && cargo test
```

### View Timing Logs

```bash
# Run with the large OpenAPI spec
RUST_LOG=info cargo run -- serve \
  --http-port 3000 \
  --openapi-spec benchmarks/startup/large_api_100_endpoints.json

# Look for log messages with timing information
```

## Performance Impact

### HTTP Server

**Overhead**: Negligible (<1ms)
- `Instant::now()` calls are very cheap (~50ns each)
- Logging is async and buffered
- Total overhead: ~5-10 `Instant` operations = <1μs

**Benefits**:
- Visibility into startup phases
- Data-driven optimization decisions
- Production debugging capability

### gRPC Server

**Overhead**: Negligible (<1ms)
- Same minimal timing overhead as HTTP
- Proto parsing dominates (50-200ms), so <1ms overhead is negligible

## Backward Compatibility

All changes are **backward compatible**:

✅ No API changes
✅ No behavior changes (only logging)
✅ No configuration changes required
✅ Existing code continues to work

The timing instrumentation is:
- Non-invasive (only adds logging)
- Controllable via log levels (disable with `RUST_LOG=warn`)
- Zero runtime cost when logging is disabled

## Future Enhancements

Based on the analysis, potential future improvements include:

### High Priority
1. **Batch Proto Compilation** - Compile multiple proto files in one protoc invocation
   - Location: `crates/mockforge-grpc/src/dynamic/proto_parser.rs`
   - Expected benefit: 2-5x faster for multiple files

2. **Descriptor Set Caching** - Cache compiled proto descriptors
   - Location: `crates/mockforge-grpc/src/dynamic/proto_parser.rs`
   - Expected benefit: Near-instant startup on re-runs

### Medium Priority
3. **Parallel Route Generation** - Use rayon for parallel route generation
   - Location: `crates/mockforge-core/src/openapi_routes.rs`
   - Expected benefit: 1.5-2x faster for large specs (if CPU-bound)

4. **Lazy Loading Option** - Generate routes on first request
   - Location: `crates/mockforge-http/src/lib.rs`
   - Trade-off: Faster startup, slower first request

## Maintenance Notes

### Log Levels

The instrumentation uses these log levels:

- `info!` - Major milestones with timing (always show in production)
  - Spec loading, route registry creation, total startup time
- `debug!` - Detailed timing for sub-operations (development only)
  - Route extraction, individual phases
- `warn!` - Errors or unexpected slow operations (always show)

### Updating Timing

When modifying startup code:

1. Add `let start = Instant::now()` before the operation
2. Add `let duration = start.elapsed()` after the operation
3. Add `info!` or `debug!` log with timing
4. Update this documentation

### Testing Instrumentation

When adding new instrumentation:

1. Verify logs appear with `RUST_LOG=info`
2. Verify logs are suppressed with `RUST_LOG=warn`
3. Run benchmarks to measure overhead
4. Update expected performance targets

## References

- [Rust std::time::Instant](https://doc.rust-lang.org/std/time/struct.Instant.html)
- [tracing crate](https://docs.rs/tracing/)
- [Performance profiling in Rust](https://nnethercote.github.io/perf-book/)

## Questions?

For questions about these changes:
- Review the comprehensive analysis: `STARTUP_LATENCY_ANALYSIS.md`
- Check the code comments in the modified files
- Open an issue on GitHub with the `performance` label
